-- jjs_agent_v_final.lua
-- Unified LocalScript: steering movement + local occupancy map (128 studs, 0.5s) +
-- BV reuse + anti-stuck + attacks/bandit + Q-learning + prioritized replay + pruning +
-- safe atomic save/load + diagnostics.
-- Focus: robustness (nil-guards, pcall), resource caps, adaptive sensors, deferred attack rewards.

-- ===== Services =====
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local Debris = game:GetService("Debris")
local LocalPlayer = Players.LocalPlayer

local okVIM, VIM = pcall(function() return game:GetService("VirtualInputManager") end)
if not okVIM then VIM = nil end

-- ===== CONFIG (tweakable) =====
local CFG = {
    sensorRaysBase = 16,
    sensorDist = 128,
    localRadius = 12,
    gridStep = 1,
    moveSpeed = 140,
    avoidAngles = {20,45,90,135},
    stuckThreshold = 0.9,
    stuckWindow = 1.0,
    mapSaveInterval = 60,
    mapFile = "jjs_map.json",
    banditFile = "jjs_bandit.json",
    qFile = "jjs_q.json",
    replayFile = "jjs_replay.json",
    metaFile = "jjs_meta.json",
    replayCap = 3000,
    replayBatch = 16,
    alpha = 0.55,
    gamma = 0.9,
    epsilon = 0.9,
    epsilonMin = 0.04,
    epsilonDecay = 0.995,
    attackRange = 10,
    damageWindow = 2.2,
    attackBurstDelay = 0.14,
    mapUpdateInterval = 0.5,
    saveInterval = 20,
    maxConcurrentMonitors = 6,
    maxMapEntries = 20000,
    maxQstates = 5000,
    maxBanditContexts = 1000,
    BVName = "_JJS_BV",
    maxReplayCap = 5000,
    minFPSForHighRays = 30,
    lowFPSRays = 6,
    highFPSRays = 20,
    pruneInterval = 300,
    debug = false,
}

-- ===== SAFE IO helpers (atomic-ish) =====
local function hasFileIO()
    return (type(isfile) == "function") and (type(readfile) == "function") and (type(writefile) == "function")
end

local function safeLoadJSON(name)
    if not hasFileIO() then return nil end
    local ok, txt = pcall(readfile, name)
    if not ok or type(txt) ~= "string" then return nil end
    local ok2, obj = pcall(HttpService.JSONDecode, HttpService, txt)
    if ok2 and type(obj) == "table" then return obj end
    return nil
end

local function safeSaveJSONAtomic(name, obj)
    if not hasFileIO() then return false end
    local payload
    local okEnc, enc = pcall(HttpService.JSONEncode, HttpService, obj)
    if not okEnc or type(enc) ~= "string" then return false end
    local tmp = name .. ".tmp"
    local ok, err = pcall(writefile, tmp, enc)
    if not ok then return false end
    -- attempt atomic swap: write tmp then overwrite main
    local ok2, err2 = pcall(writefile, name, enc)
    if not ok2 then
        -- leave tmp if overwrite failed
        return false
    end
    return true
end

-- ===== Persistent structures =====
local mapMemory = safeLoadJSON(CFG.mapFile) or {}        -- posKey -> {kind="free"/"blocked", t = tick(), c=confidence}
local bandit = safeLoadJSON(CFG.banditFile) or {}       -- ctx -> {meta={...}, attackName = {wins,plays}}
local Q = safeLoadJSON(CFG.qFile) or {}                 -- state -> array of action-values
local ReplayMem = safeLoadJSON(CFG.replayFile) or nil   -- optional persistence (not used by default)
local meta = safeLoadJSON(CFG.metaFile) or {version=1, created=os.time(), lastSave=os.time()}

-- ===== runtime binds =====
local char, humanoid, hrp, camera
local function bindCharacter()
    if not LocalPlayer then return end
    local ok, cp = pcall(function() return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() end)
    if not ok or not cp then return end
    char = cp
    humanoid = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
    hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")
    camera = workspace.CurrentCamera
end
pcall(bindCharacter)
if LocalPlayer and LocalPlayer.CharacterAdded then
    LocalPlayer.CharacterAdded:Connect(function() task.wait(0.08); pcall(bindCharacter) end)
end
workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() camera = workspace.CurrentCamera end)

-- ===== Utilities =====
local function log(...)
    if CFG.debug then print("[JJS]", ...) end
end

local function posKey(vec)
    if not vec then return "nil" end
    local x = math.floor((vec.X) / CFG.gridStep + 0.5)
    local y = math.floor((vec.Y) / CFG.gridStep + 0.5)
    local z = math.floor((vec.Z) / CFG.gridStep + 0.5)
    return x .. "|" .. y .. "|" .. z
end

local function safeMag(a,b)
    if not a or not b then return math.huge end
    local ok, v = pcall(function() return (a-b).Magnitude end)
    if ok and v then return v end
    return math.huge
end

-- clamp
local function clamp(v, lo, hi) if v < lo then return lo end if v > hi then return hi end return v end

-- ===== Adaptive sensor tuning based on recent dt (fps) =====
local recentDT = {0.016}
local function avgFPS()
    local s = 0
    for i=1,#recentDT do s = s + recentDT[i] end
    local avgdt = s / #recentDT
    return 1 / math.max(avgdt, 1e-3)
end

-- ===== Raycast / Sensors =====
local function raycastFrom(origin, dir, length, filterList)
    if not origin or not dir then return nil end
    local rp = RaycastParams.new()
    rp.FilterDescendantsInstances = filterList or {char}
    rp.FilterType = Enum.RaycastFilterType.Blacklist
    rp.IgnoreWater = true
    local ok, res = pcall(function() return workspace:Raycast(origin + Vector3.new(0,1.5,0), dir.Unit * (length or CFG.sensorDist), rp) end)
    if ok then return res else return nil end
end

local function chooseSensorRays()
    local fps = avgFPS()
    if fps >= CFG.minFPSForHighRays then return CFG.highFPSRays end
    if fps < 10 then return CFG.lowFPSRays end
    -- linear interpolation
    local ratio = (fps - 10) / (CFG.minFPSForHighRays - 10)
    return math.floor(CFG.lowFPSRays + (CFG.highFPSRays - CFG.lowFPSRays) * clamp(ratio, 0, 1))
end

local function scanRing(origin, rays)
    rays = rays or CFG.sensorRaysBase
    origin = origin or (hrp and hrp.Position) or workspace.CurrentCamera and workspace.CurrentCamera.CFrame.Position or Vector3.new(0,0,0)
    local out = {}
    for i=0, rays-1 do
        local ang = (i / math.max(1, rays)) * math.pi * 2
        local dir = Vector3.new(math.cos(ang), 0, math.sin(ang))
        local res = raycastFrom(origin, dir, CFG.sensorDist)
        out[i+1] = {dir=dir, hit=(res~=nil), dist=(res and (res.Position - origin).Magnitude) or CFG.sensorDist, inst=(res and res.Instance) or nil}
    end
    return out
end

-- update mapMemory with midpoints and simple confidence
local function updateMapOnce()
    if not hrp then return end
    local origin = hrp.Position
    local rays = chooseSensorRays()
    local scan = scanRing(origin, rays)
    for i=1,#scan do
        local s = scan[i]
        local samplePos = origin + s.dir * math.min((s.dist or CFG.sensorDist) * 0.5, CFG.sensorDist)
        local key = posKey(samplePos)
        if key and key ~= "nil" then
            local nowt = tick()
            local prev = mapMemory[key]
            if s.hit then
                mapMemory[key] = {kind="blocked", t = nowt, c = (prev and math.min(1, (prev.c or 0) + 0.4)) or 0.6}
            else
                mapMemory[key] = {kind="free", t = nowt, c = (prev and math.min(1, (prev.c or 0) + 0.3)) or 0.5}
            end
        end
    end
end

-- periodic map updater
task.spawn(function()
    while true do
        task.wait(CFG.mapUpdateInterval)
        pcall(updateMapOnce)
    end
end)

-- ===== Map pruning =====
local function pruneMap()
    -- remove oldest or low-confidence entries if mapMemory too large
    local cnt = 0
    for _ in pairs(mapMemory) do cnt = cnt + 1 end
    if cnt <= CFG.maxMapEntries then return end
    local list = {}
    for k,v in pairs(mapMemory) do
        table.insert(list, {k=k, t = v.t or 0, c = v.c or 0})
    end
    table.sort(list, function(a,b)
        if a.c ~= b.c then return a.c < b.c end
        return a.t < b.t
    end)
    local removeCount = math.max(1, cnt - CFG.maxMapEntries)
    for i=1, removeCount do mapMemory[list[i].k] = nil end
    collectgarbage("collect")
end

-- ===== BodyVelocity reuse & smoothing =====
local function ensureBV()
    if not hrp then return nil end
    local existing = hrp:FindFirstChild(CFG.BVName)
    if existing and existing:IsA("BodyVelocity") then return existing end
    local ok, obj = pcall(function()
        local b = Instance.new("BodyVelocity")
        b.Name = CFG.BVName
        b.MaxForce = Vector3.new(1e6,0,1e6)
        b.P = 3000
        b.Parent = hrp
        return b
    end)
    return ok and obj or nil
end

local function setVelocity(vec)
    local bv = ensureBV()
    if not bv then return end
    -- smooth via lerp on client side
    local cur = bv.Velocity or Vector3.new(0,0,0)
    local target = Vector3.new(vec.X, 0, vec.Z)
    -- simple smoothing factor
    local s = 0.6
    local v = Vector3.new(cur.X * (1-s) + target.X * s, 0, cur.Z * (1-s) + target.Z * s)
    bv.Velocity = v
end

local function clearBV()
    if not hrp then return end
    local b = hrp:FindFirstChild(CFG.BVName)
    if b and b.Parent then pcall(function() b:Destroy() end) end
end

-- ===== Movement helpers =====
local function rotateYUnit(vec, deg)
    if not vec or vec.Magnitude < 1e-6 then return nil end
    local cf = CFrame.Angles(0, math.rad(deg), 0)
    local r = cf:VectorToWorldSpace(vec)
    if r.Magnitude < 1e-6 then return nil end
    return Vector3.new(r.X,0,r.Z).Unit
end

local function isPathClearSimple(fromPos, dirUnit, length)
    if not fromPos or not dirUnit or dirUnit.Magnitude < 1e-6 then return false end
    length = length or math.min(CFG.sensorDist, 16)
    local res = raycastFrom(fromPos, dirUnit, length)
    return res == nil
end

local function steerTo(desiredUnit)
    if not hrp or not desiredUnit or desiredUnit.Magnitude < 1e-6 then return nil end
    if isPathClearSimple(hrp.Position, desiredUnit, math.min(16, CFG.sensorDist)) then return desiredUnit end
    for _,a in ipairs(CFG.avoidAngles) do
        local r = rotateYUnit(desiredUnit, a)
        local l = rotateYUnit(desiredUnit, -a)
        if r and isPathClearSimple(hrp.Position, r, 10) then return r end
        if l and isPathClearSimple(hrp.Position, l, 10) then return l end
    end
    -- fallback to any free scan direction
    local s = scanRing(hrp.Position, math.min(12, chooseSensorRays()))
    for i=1,#s do if not s[i].hit then return s[i].dir end end
    return nil
end

-- anti-stuck telemetry
local recentPos = {}
local function recordPosition()
    if not hrp then return end
    table.insert(recentPos, 1, hrp.Position)
    local cap = math.ceil(CFG.stuckWindow / 0.06) + 2
    if #recentPos > cap then table.remove(recentPos) end
end

local function detectStuck()
    if #recentPos < 4 then return false end
    local sum = 0
    for i=1, math.min(#recentPos-1, 6) do
        local a = recentPos[i]; local b = recentPos[i+1]
        if a and b then sum = sum + (a - b).Magnitude end
    end
    return sum < CFG.stuckThreshold
end

-- ===== Targeting & camera =====
local function findNearestTarget()
    if not hrp then pcall(bindCharacter) end
    local best, bestD = nil, math.huge
    for _,pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character.Parent then
            local ch = pl.Character
            local hrp2 = ch:FindFirstChild("HumanoidRootPart")
            local hum = ch:FindFirstChildOfClass("Humanoid")
            if hrp2 and hum and hum.Health and hum.Health > 0 then
                local ok, d = pcall(function() return (hrp.Position - hrp2.Position).Magnitude end)
                if ok and d and d < bestD then best, bestD = ch, d end
            end
        end
    end
    return best, bestD
end

local function lookAtTarget(target)
    if not camera or not target or not target:FindFirstChild("Head") then return end
    pcall(function()
        local pos = camera.CFrame.Position
        local want = CFrame.new(pos, target.Head.Position)
        camera.CFrame = camera.CFrame:Lerp(want, 0.7)
    end)
end

-- ===== Bandit (attack selection) =====
local baseAttacks = {"click","heavy","skill1","skill2","skill3","skill4"}
local function ensureContext(ctx)
    ctx = ctx or "glob"
    if not bandit[ctx] then bandit[ctx] = {meta = {created = tick(), last = tick()}} end
    for _,nm in ipairs(baseAttacks) do if not bandit[ctx][nm] then bandit[ctx][nm] = {wins=0,plays=0} end end
    bandit[ctx].meta.last = tick()
    return bandit[ctx]
end

local function chooseAttackForContext(ctx)
    local tb = ensureContext(ctx)
    local total = 0
    for k,v in pairs(tb) do if type(v)=="table" and v.plays then total = total + (v.plays or 0) end end
    total = math.max(1, total)
    local best, bestVal = nil, -math.huge
    for name,st in pairs(tb) do
        if type(st)=="table" and st.plays ~= nil then
            local plays = st.plays or 0
            local wins = st.wins or 0
            local avg = (plays>0) and (wins/plays) or 0.35
            local bonus = (plays>0) and math.sqrt(2*math.log(total)/plays) or 1.0
            local val = avg + bonus
            if val > bestVal then bestVal, best = val, name end
        end
    end
    return best or "click"
end

local function registerAttack(ctx, name, success)
    ctx = ctx or "glob"
    ensureContext(ctx)
    local s = bandit[ctx][name] or {wins=0,plays=0}
    s.plays = (s.plays or 0) + 1
    if success then s.wins = (s.wins or 0) + 1 end
    bandit[ctx][name] = s
    -- throttle saves (async)
    task.spawn(function() pcall(function() safeSaveJSONAtomic(CFG.banditFile, bandit) end) end)
end

-- ===== VIM inputs (safe) =====
local function doClick()
    if not VIM or not camera then return end
    local ok, size = pcall(function() return camera.ViewportSize end)
    if not ok or not size then return end
    local x,y = size.X/2, size.Y/2
    pcall(function() VIM:SendMouseButtonEvent(x,y,0,true,game,0); task.wait(0.03); VIM:SendMouseButtonEvent(x,y,0,false,game,0) end)
end
local function doHeavy()
    if not VIM or not camera then return end
    local ok, size = pcall(function() return camera.ViewportSize end)
    if not ok or not size then return end
    local x,y = size.X/2, size.Y/2
    pcall(function() VIM:SendMouseButtonEvent(x,y,0,true,game,0); task.wait(0.12); VIM:SendMouseButtonEvent(x,y,0,false,game,0) end)
end
local skillKeys = {Enum.KeyCode.One,Enum.KeyCode.Two,Enum.KeyCode.Three,Enum.KeyCode.Four}
local function pressSkill(i)
    if not VIM or not skillKeys[i] then return end
    pcall(function() VIM:SendKeyEvent(true, skillKeys[i], false, game); task.wait(0.06); VIM:SendKeyEvent(false, skillKeys[i], false, game) end)
end

-- ===== Monitor target damage (deferred reward) =====
local activeMonitors = 0
local maxMonitors = CFG.maxConcurrentMonitors
local function monitorTargetDamage(target, startHP, window, cb)
    if not target or not cb then return end
    window = window or CFG.damageWindow
    if activeMonitors >= maxMonitors then
        task.spawn(function() task.wait(math.min(0.2, window)); local ok, cur = pcall(function() return target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health end); pcall(cb, ok and cur and startHP and cur < startHP) end)
        return
    end
    activeMonitors = activeMonitors + 1
    task.spawn(function()
        local t0 = tick(); local success = false
        while tick() - t0 < window do
            if not (target and target.Parent) then break end
            local ok, cur = pcall(function() return target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health end)
            if ok and cur and startHP and cur < startHP then success = true; break end
            task.wait(0.04)
        end
        pcall(cb, success)
        activeMonitors = math.max(0, activeMonitors - 1)
    end)
end

-- ===== Q-learning & Replay (prioritized-ish) =====
local actions = {"approach","strafe_left","strafe_right","retreat","idle","click","skill1","skill2","skill3","skill4"}

local function initState(s)
    if not s then return end
    if not Q[s] then
        if type(Q) ~= "table" then Q = {} end
        Q[s] = {}
        for i=1,#actions do Q[s][i] = 0 end
    end
end

local function chooseActionEps(s)
    initState(s)
    if math.random() < CFG.epsilon then return math.random(1,#actions) end
    local bestVal, idx = -math.huge, 1
    for i,v in ipairs(Q[s]) do if v > bestVal then bestVal, idx = v, i end end
    return idx
end

-- Replay memory (simple prioritized by |r|)
local Replay = {mem = {}, cap = math.min(CFG.replayCap, CFG.maxReplayCap), sz = 0, idx = 1}
function Replay.add(s,a,r,ns,done)
    if not s then return end
    local priority = math.min(100, math.abs(r) + 0.0001)
    local entry = {s=s,a=a,r=r,ns=ns,done=done,p=priority}
    Replay.mem[Replay.idx] = entry
    Replay.idx = (Replay.idx % Replay.cap) + 1
    if Replay.sz < Replay.cap then Replay.sz = Replay.sz + 1 end
end
function Replay.sample(n)
    if Replay.sz == 0 then return {} end
    n = math.min(n, Replay.sz)
    -- simple weighted sampling
    local total = 0
    for i=1,Replay.sz do total = total + (Replay.mem[i].p or 0) end
    if total <= 0 then
        local out = {}
        for i=1,n do out[#out+1] = Replay.mem[math.random(1,Replay.sz)] end
        return out
    end
    local out = {}
    for k=1,n do
        local pick = math.random() * total
        local acc = 0
        for i=1, Replay.sz do
            acc = acc + (Replay.mem[i].p or 0)
            if acc >= pick then out[#out+1] = Replay.mem[i]; break end
        end
    end
    return out
end

local function updateQ(state, aIdx, reward, nextState)
    if not state or not aIdx then return end
    initState(state); initState(nextState)
    local maxNext = -math.huge
    for i,v in ipairs(Q[nextState]) do if v > maxNext then maxNext = v end end
    if maxNext == -math.huge then maxNext = 0 end
    Q[state][aIdx] = Q[state][aIdx] + CFG.alpha * (reward + CFG.gamma * maxNext - Q[state][aIdx])
end

local function replayTrain()
    if Replay.sz < 1 then return end
    local batch = Replay.sample(CFG.replayBatch)
    for _,t in ipairs(batch) do
        if t and t.s and t.a then updateQ(t.s, t.a, t.r, t.ns) end
    end
end

-- Q pruning
local function pruneQ()
    local count = 0
    for _ in pairs(Q) do count = count + 1 end
    if count <= CFG.maxQstates then return end
    local tbl = {}
    for k,v in pairs(Q) do
        local s = 0
        for i=1,#v do s = s + math.abs(v[i] or 0) end
        table.insert(tbl, {k=k,score=s})
    end
    table.sort(tbl, function(a,b) return a.score < b.score end)
    for i=1, math.min(#tbl, count - CFG.maxQstates) do Q[tbl[i].k] = nil end
    collectgarbage("collect")
end

-- Bandit pruning
local function pruneBandit()
    local keys = {}
    for k,v in pairs(bandit) do
        if type(v)=="table" and v.meta then
            local total = 0
            for an,av in pairs(v) do if type(av)=="table" and av.plays then total = total + (av.plays or 0) end end
            table.insert(keys, {k=k,score=total,last=v.meta.last})
        end
    end
    table.sort(keys, function(a,b) return a.score > b.score end)
    for i = CFG.maxBanditContexts+1, #keys do bandit[keys[i].k] = nil end
    collectgarbage("collect")
end

-- Replay prune (simple)
local function pruneReplay()
    if Replay.sz <= Replay.cap then return end
    -- shrink by half oldest entries
    local keep = math.floor(Replay.cap * 0.6)
    local newmem = {}
    local p = 1
    for i=1,keep do
        newmem[p] = Replay.mem[i]
        p = p + 1
    end
    Replay.mem = newmem
    Replay.sz = math.min(Replay.sz, keep)
    Replay.idx = Replay.sz + 1
    collectgarbage("collect")
end

-- periodic prune schedule
task.spawn(function()
    while true do
        task.wait(CFG.pruneInterval)
        pcall(pruneMap); pcall(pruneQ); pcall(pruneBandit); pcall(pruneReplay)
        pcall(function() safeSaveJSONAtomic(CFG.qFile, Q) end)
    end
end)

-- ===== Rewards & State building =====
local lastActionIdx = nil
local lastSkill = nil
local lastMyHealth = nil

local function compressRecent(lastActions)
    if not lastActions or #lastActions == 0 then return "m_none" end
    local start = math.max(1, #lastActions - 2)
    local out = "m"
    for i=start,#lastActions do out = out .. "_" .. tostring(lastActions[i]) end
    return out
end

local function computeState(target, recentActions)
    if not target or not target.Parent or not target:FindFirstChild("HumanoidRootPart") then return "no_target" end
    local dist = safeMag(hrp.Position, target.HumanoidRootPart.Position)
    local range = (dist < 6 and "close") or (dist < 15 and "mid") or "far"
    local vis = "novis"
    if target:FindFirstChild("Head") then
        local r = raycastFrom(hrp.Position, (target.Head.Position - hrp.Position), CFG.sensorDist)
        if r == nil or (r.Instance and r.Instance:IsDescendantOf(target)) then vis = "vis" end
    end
    local hpFrac = 1
    pcall(function() local h = target:FindFirstChildOfClass("Humanoid"); if h then hpFrac = (h.Health / math.max(1, h.MaxHealth or 1)) end end)
    local hpb = (hpFrac>0.7 and "hp_high") or (hpFrac>0.3 and "hp_med") or "hp_low"
    local mem = compressRecent(recentActions)
    local state = table.concat({range, vis, hpb, mem}, "|")
    if #state > 200 then state = state:sub(1,200) end
    return state
end

local function computeReward(actionIdx, target, oldDist, collidedWithWall, gotDamage, didDamage, targetMovedAway)
    local r = 0
    local actionName = actions[actionIdx] or "idle"
    if target then
        local newDist = safeMag(hrp.Position, target.HumanoidRootPart.Position)
        if newDist < oldDist then r = r + 0.6 else r = r - 0.35 end
        if targetMovedAway then r = r - 0.9 end
    else r = r - 0.8 end
    if collidedWithWall then r = r - 2.2 end
    if gotDamage then r = r - 2.5 end
    if didDamage then r = r + 3.2 end
    if actionName:match("skill") then
        if lastSkill == actionName then r = r - 1.2 end
        lastSkill = actionName
    else lastSkill = nil end
    if lastActionIdx == actionIdx then r = r - 0.06 end
    lastActionIdx = actionIdx
    if actionName == "idle" then r = r - 0.05 end
    return r
end

-- ===== Pending attacks queue (deferred reward) =====
local pendingAttacks = {}  -- id -> {state,aIdx,oldDist,ctx,time}

local function enqueuePendingAttack(entry)
    if not entry then return end
    local id = tostring(tick()) .. "_" .. tostring(math.random(1,1e6))
    pendingAttacks[id] = entry
    -- auto cleanup old entries
    task.spawn(function()
        task.wait(CFG.damageWindow + 2)
        pendingAttacks[id] = nil
    end)
    return id
end

-- ===== Main loop: integrate perception, action, learning, movement, attacks =====
local recentActions = {}
local loopTick = 0

-- heartbeat-driven main loop
task.spawn(function()
    local hb = RunService.Heartbeat
    local lastTime = tick()
    while true do
        local dt = hb:Wait()
        -- update recent dt for fps calc
        table.insert(recentDT, 1, dt)
        if #recentDT > 60 then table.remove(recentDT) end

        loopTick = loopTick + 1
        pcall(bindCharacter)
        if not (char and char.Parent and humanoid and hrp) then task.wait(0.02) goto MAIN_CONTINUE end

        recordPosition()

        -- find nearest
        local target, oldDist = findNearestTarget()
        oldDist = oldDist or math.huge

        -- build state and choose action
        local state = computeState(target, recentActions)
        initState(state)
        local aIdx = chooseActionEps(state)
        local action = actions[aIdx] or "idle"

        -- defaults
        local collided = false; local gotDamage = false; local didDamage = false; local targetMovedAway = false

        -- perform action
        if action == "approach" then
            if target and target:FindFirstChild("HumanoidRootPart") then
                local ok, raw = pcall(function() return (target.HumanoidRootPart.Position - hrp.Position) end)
                if ok and raw then
                    local flat = Vector3.new(raw.X,0,raw.Z)
                    if flat.Magnitude > 0.3 then
                        local desired = flat.Unit
                        local steer = steerTo(desired)
                        if steer then setVelocity(steer * CFG.moveSpeed) else collided = true; clearBV() end
                    end
                end
            end

        elseif action == "strafe_left" then
            if target and target:FindFirstChild("HumanoidRootPart") then
                local ok, raw = pcall(function() return (target.HumanoidRootPart.Position - hrp.Position) end)
                if ok and raw then
                    local left = Vector3.new(-raw.Z,0,raw.X)
                    if left.Magnitude > 0.2 then
                        local steer = steerTo(left.Unit)
                        if steer then setVelocity(steer * CFG.moveSpeed * 0.9) else collided = true; clearBV() end
                    end
                end
            end

        elseif action == "strafe_right" then
            if target and target:FindFirstChild("HumanoidRootPart") then
                local ok, raw = pcall(function() return (target.HumanoidRootPart.Position - hrp.Position) end)
                if ok and raw then
                    local right = Vector3.new(raw.Z,0,-raw.X)
                    if right.Magnitude > 0.2 then
                        local steer = steerTo(right.Unit)
                        if steer then setVelocity(steer * CFG.moveSpeed * 0.9) else collided = true; clearBV() end
                    end
                end
            end

        elseif action == "retreat" then
            if target and target:FindFirstChild("HumanoidRootPart") then
                local ok, raw = pcall(function() return (hrp.Position - target.HumanoidRootPart.Position) end)
                if ok and raw and raw.Magnitude > 0.2 then
                    local steer = steerTo(raw.Unit)
                    if steer then setVelocity(steer * CFG.moveSpeed) else collided = true; clearBV() end
                end
            end

        elseif action == "idle" then
            clearBV()
            task.wait(0.02)

        elseif action == "click" or action:match("^skill") then
            -- perform attack and enqueue pending reward check
            local ctx = computeState(target, recentActions)
            local atkName = (action == "click") and "click" or action
            local startHP = (target and target:FindFirstChildOfClass("Humanoid") and target.Humanoid.Health) or nil
            -- execute input
            if action == "click" then doClick() elseif action == "skill1" or action == "skill2" or action == "skill3" or action == "skill4" then
                local idx = tonumber(action:match("skill(%d)"))
                if idx then pressSkill(idx) end
            end
            -- enqueue pending attack for deferred reward
            local entry = {state=state, aIdx=aIdx, oldDist=oldDist, ctx=ctx, time=tick(), atk=atkName}
            local id = enqueuePendingAttack(entry)
            monitorTargetDamage(target, startHP, CFG.damageWindow, function(success)
                local e = pendingAttacks[id]
                if e then
                    local r = computeReward(e.aIdx, target, e.oldDist, false, false, success, false)
                    Replay.add(e.state, e.aIdx, r, computeState(target, recentActions), false)
                    updateQ(e.state, e.aIdx, r, computeState(target, recentActions))
                    pcall(function() registerAttack(e.ctx, e.atk, success) end)
                    pendingAttacks[id] = nil
                end
            end)
        end

        -- camera
        if target then lookAtTarget(target) end

        -- detect my damage (simple)
        local curMy = nil
        pcall(function() curMy = humanoid and humanoid.Health end)
        if lastMyHealth and curMy and curMy < lastMyHealth then gotDamage = true end
        if curMy then lastMyHealth = curMy end

        -- detect target moved away
        if target and target:FindFirstChild("HumanoidRootPart") and oldDist ~= math.huge then
            local ok, newD = pcall(function() return (hrp.Position - target.HumanoidRootPart.Position).Magnitude end)
            if ok and newD and newD > oldDist + 0.4 then targetMovedAway = true end
        end

        -- learning: immediate reward for non-attack actions; attacks handled deferred
        if not (action == "click" or action:match("^skill")) then
            local reward = computeReward(aIdx, target, oldDist, collided, gotDamage, false, targetMovedAway)
            pushRecent = function(a) recentActions[#recentActions+1] = a; if #recentActions > 6 then table.remove(recentActions,1) end end
            recentActions[#recentActions+1] = aIdx; if #recentActions > 6 then table.remove(recentActions,1) end
            local nextState = computeState(target, recentActions)
            Replay.add(state, aIdx, reward, nextState, false)
            updateQ(state, aIdx, reward, nextState)
        else
            recentActions[#recentActions+1] = aIdx; if #recentActions > 6 then table.remove(recentActions,1) end
        end

        -- epsilon decay
        if CFG.epsilon and CFG.epsilon > CFG.epsilonMin then CFG.epsilon = math.max(CFG.epsilon * CFG.epsilonDecay, CFG.epsilonMin) end

        -- periodic replay train
        if loopTick % 6 == 0 then pcall(replayTrain) end
        if loopTick % 300 == 0 then pcall(function() pruneQ(); pruneMap(); pruneBandit(); pruneReplay(); collectgarbage("collect") end) end

        task.wait(0.02)
        ::MAIN_CONTINUE::
    end
end)

-- ===== Save / autosave / BindToClose =====
local lastSave = tick()
task.spawn(function()
    while true do
        task.wait(CFG.saveInterval)
        safeSaveJSONAtomic(CFG.mapFile, mapMemory)
        safeSaveJSONAtomic(CFG.banditFile, bandit)
        safeSaveJSONAtomic(CFG.qFile, Q)
        meta.lastSave = os.time()
        safeSaveJSONAtomic(CFG.metaFile, meta)
    end
end)

game:BindToClose(function()
    safeSaveJSONAtomic(CFG.mapFile, mapMemory)
    safeSaveJSONAtomic(CFG.banditFile, bandit)
    safeSaveJSONAtomic(CFG.qFile, Q)
    meta.lastSave = os.time()
    safeSaveJSONAtomic(CFG.metaFile, meta)
    pcall(function() collectgarbage("collect") end)
end)

-- ===== Diagnostics API =====
_G.JJS_AGENT = _G.JJS_AGENT or {}
_G.JJS_AGENT.status = function()
    local qcount = 0 for _ in pairs(Q) do qcount = qcount + 1 end
    local mcount = 0 for _ in pairs(mapMemory) do mcount = mcount + 1 end
    local bcount = 0 for _ in pairs(bandit) do bcount = bcount + 1 end
    print(("JJS status: qstates=%d map=%d bandit=%d replay=%d eps=%.4f fps=%.1f"):format(qcount, mcount, bcount, Replay.sz, CFG.epsilon, avgFPS()))
end

_G.JJS_AGENT.saveNow = function()
    safeSaveJSONAtomic(CFG.mapFile, mapMemory)
    safeSaveJSONAtomic(CFG.banditFile, bandit)
    safeSaveJSONAtomic(CFG.qFile, Q)
    meta.lastSave = os.time()
    safeSaveJSONAtomic(CFG.metaFile, meta)
    print("[JJS] saved")
end

_G.JJS_AGENT.clearMemory = function()
    mapMemory = {}; bandit = {}; Q = {}; Replay.mem = {}; Replay.sz = 0; Replay.idx = 1
    safeSaveJSONAtomic(CFG.mapFile, mapMemory); safeSaveJSONAtomic(CFG.banditFile, bandit); safeSaveJSONAtomic(CFG.qFile, Q)
    print("[JJS] cleared memory")
end

print("[JJS AGENT] final unified agent loaded")