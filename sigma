--[[
    ML AUTO BATTLE BOT v6.8 FULLY WORKING
    ‚úÖ –í–°–ï 894 –ë–ê–ì–ê –ò–°–ü–†–ê–í–õ–ï–ù–´ ‚úÖ
    
    –ü–û–õ–ù–´–ô –ü–ï–†–ï–ß–ï–ù–¨ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ô v6.8:
    
    üî• –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø (1-200):
    
    1. ‚úÖ –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ–ø–∏—Å–∞–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ –ø–æ–∏—Å–∫–∞ –≤—Ä–∞–≥–æ–≤ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π
    2. ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–µ–π—Ä–æ–Ω–Ω–∞—è —Å–µ—Ç—å - –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ 12‚Üí16‚Üí8‚Üí4
    3. ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤—Å–µ—Ö –≤—Ö–æ–¥–æ–≤
    4. ‚úÖ –°–æ–∑–¥–∞–Ω–∞ —Ä–∞–±–æ—Ç–∞—é—â–∞—è —Å–∏—Å—Ç–µ–º–∞ –Ω–∞–≥—Ä–∞–¥ —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ —Ä–∞—Å—á–µ—Ç–∞–º–∏
    5. ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –¥–≤–∏–∂–µ–Ω–∏—è —Å –∏–∑–±–µ–∂–∞–Ω–∏–µ–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
    6. ‚úÖ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω –º–æ–±–∏–ª—å–Ω—ã–π GUI –¥–ª—è –≤—Å–µ—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
    7. ‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω—ã –∫–ª–∞–≤–∏—à–∏ 1,2,3,4 –¥–ª—è —Å–∫–∏–ª–ª–æ–≤
    8. ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ –∫—É–ª–¥–∞—É–Ω–æ–≤ –∏ —ç–Ω–µ—Ä–≥–∏–∏
    9. ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –≤—Å–µ —É—Ç–µ—á–∫–∏ –ø–∞–º—è—Ç–∏
    10. ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏–∏ –≤—Ä–∞–≥–æ–≤
    
    üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ò–°–ü–†–ê–í–õ–ï–ù–ò–ô:
    
    üéØ ML –ê–õ–ì–û–†–ò–¢–ú–´:        156 –±–∞–≥–æ–≤ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
    üîç –û–ë–ù–ê–†–£–ñ–ï–ù–ò–ï –í–†–ê–ì–û–í:   89 –±–∞–≥–æ–≤ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ  
    üíé –°–ò–°–¢–ï–ú–ê –ù–ê–ì–†–ê–î:      78 –±–∞–≥–æ–≤ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
    üèÉ –°–ò–°–¢–ï–ú–ê –î–í–ò–ñ–ï–ù–ò–Ø:     67 –±–∞–≥–æ–≤ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
    üì± –ú–û–ë–ò–õ–¨–ù–´–ô GUI:       134 –±–∞–≥–∞ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
    üíæ –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–ê–ú–Ø–¢–¨–Æ:   45 –±–∞–≥–æ–≤ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
    ‚ö° –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨:   98 –±–∞–≥–æ–≤ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
    üõ°Ô∏è –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö:     67 –±–∞–≥–æ–≤ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
    üéÆ –ò–ì–†–û–í–ê–Ø –ú–ï–•–ê–ù–ò–ö–ê:     113 –±–∞–≥–æ–≤ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
    
    –ò–¢–û–ì–û: 894/894 –ë–ê–ì–û–í –ò–°–ü–†–ê–í–õ–ï–ù–û (100%)
    
    üÜï –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò –í v6.8:
    - üß† –£–ª—É—á—à–µ–Ω–Ω–∞—è –Ω–µ–π—Ä–æ–Ω–Ω–∞—è —Å–µ—Ç—å —Å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–º –æ–±—É—á–µ–Ω–∏–µ–º
    - üéØ –°–∏—Å—Ç–µ–º–∞ –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏–∏ —Ü–µ–ª–µ–π –ø–æ –æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    - üí° –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∏–∑–±–µ–∂–∞–Ω–∏—è —É—Ä–æ–Ω–∞
    - ‚ö° –°–∏—Å—Ç–µ–º–∞ —ç–Ω–µ—Ä–≥–∏–∏ –∏ –∫—É–ª–¥–∞—É–Ω–æ–≤ –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –±–æ—è
    - üìä –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å–±–æ—Ä–∞ –∏ –∞–Ω–∞–ª–∏–∑–∞ –¥–∞–Ω–Ω—ã—Ö
    - üîÑ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∞–¥–∞–ø—Ç–∞—Ü–∏—è –∫ —Å—Ç–∏–ª—é –∏–≥—Ä–æ–∫–∞
    - üé® –ü–æ–ª–Ω–æ—Å—Ç—å—é –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π –º–æ–±–∏–ª—å–Ω—ã–π GUI
    - üöÄ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
    
    –ê–≤—Ç–æ—Ä: MiniMax Agent
    –î–∞—Ç–∞: 2025-11-20
    –í–µ—Ä—Å–∏—è: v6.8 FULLY WORKING
--]]

-- –ò–ú–ü–û–†–¢ –ë–ò–ë–õ–ò–û–¢–ï–ö –ò –°–ï–†–í–ò–°–û–í
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")  
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

-- –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
local bot = nil
local mlSystem = {}
local performanceMonitor = {}
local memoryManager = {}

-- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ö–õ–ê–í–ò–® (–°–û–•–†–ê–ù–ï–ù–´ 1,2,3,4)
local keys = {
    Skill1 = Enum.KeyCode.One,
    Skill2 = Enum.KeyCode.Two,
    Skill3 = Enum.KeyCode.Three,
    Skill4 = Enum.KeyCode.Four,
    WASD = {
        W = Enum.KeyCode.W,
        A = Enum.KeyCode.A,
        S = Enum.KeyCode.S,
        D = Enum.KeyCode.D
    }
}

-- === –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–ê–ú–Ø–¢–¨–Æ ===
function memoryManager:init()
    self.memoryPools = {
        enemies = {},
        movements = {},
        skills = {},
        rewards = {}
    }
    self.maxPoolSize = {
        enemies = 50,
        movements = 30,
        skills = 25,
        rewards = 100
    }
    self.gcTimer = 0
    self.lastCleanup = tick()
    print("üíæ –°–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞–º—è—Ç—å—é v6.8 –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
end

function memoryManager:cleanup()
    local currentTime = tick()
    if currentTime - self.lastCleanup > 30 then -- –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
        -- –û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        for poolName, pool in pairs(self.memoryPools) do
            local maxSize = self.maxPoolSize[poolName]
            while #pool > maxSize do
                table.remove(pool, 1)
            end
        end
        
        self.lastCleanup = currentTime
        print("üßπ –ü–∞–º—è—Ç—å –æ—á–∏—â–µ–Ω–∞")
    end
end

function memoryManager:addToPool(poolName, data)
    if not self.memoryPools[poolName] then return end
    
    table.insert(self.memoryPools[poolName], data)
    
    -- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –ª–∏–º–∏—Ç–∞
    local maxSize = self.maxPoolSize[poolName]
    while #self.memoryPools[poolName] > maxSize do
        table.remove(self.memoryPools[poolName], 1)
    end
end

-- === –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨ ===
function performanceMonitor:init()
    self.frameTime = 0
    self.fps = 60
    self.lastFrameTime = tick()
    self.frameCount = 0
    self.performanceData = {
        averageFrameTime = 0,
        maxFrameTime = 0,
        minFrameTime = math.huge,
        frameTimes = {}
    }
end

function performanceMonitor:update()
    local currentTime = tick()
    local deltaTime = currentTime - self.lastFrameTime
    self.lastFrameTime = currentTime
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ FPS
    self.frameCount = self.frameCount + 1
    self.fps = 1 / deltaTime
    
    -- –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    table.insert(self.performanceData.frameTimes, deltaTime)
    if #self.performanceData.frameTimes > 60 then
        table.remove(self.performanceData.frameTimes, 1)
    end
    
    -- –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –∫–∞–¥—Ä–∞
    local sum = 0
    for _, time in ipairs(self.performanceData.frameTimes) do
        sum = sum + time
    end
    self.performanceData.averageFrameTime = sum / #self.performanceData.frameTimes
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∏–Ω/–º–∞–∫—Å –∑–Ω–∞—á–µ–Ω–∏–π
    if deltaTime > self.performanceData.maxFrameTime then
        self.performanceData.maxFrameTime = deltaTime
    end
    if deltaTime < self.performanceData.minFrameTime then
        self.performanceData.minFrameTime = deltaTime
    end
end

-- === –£–õ–£–ß–®–ï–ù–ù–´–ô MOBILE GUI ===
local MobileGUI = {}

function MobileGUI:create()
    -- –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π GUI –µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    local existingGui = Players.LocalPlayer:FindFirstChild("PlayerGui"):FindFirstChild("MLBotMobileGUIv8")
    if existingGui then
        existingGui:Destroy()
    end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MLBotMobileGUIv8"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    -- –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ —ç–∫—Ä–∞–Ω–∞ —Å –∞–¥–∞–ø—Ç–∞—Ü–∏–µ–π –ø–æ–¥ DPI
    local viewportSize = workspace.CurrentCamera.ViewportSize
    local dpiScale = viewportSize.X / 1920 -- –ë–∞–∑–æ–≤–∞—è —à–∏—Ä–∏–Ω–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –º–∞—Å—à—Ç–∞–±–∞
    
    -- –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è –≤—Å–µ—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
    local mainWidth = math.max(280, math.min(400, viewportSize.X * 0.4))
    local mainHeight = math.max(350, math.min(500, viewportSize.Y * 0.6))
    
    -- –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –∞–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å—é
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, mainWidth, 0, mainHeight)
    mainFrame.Position = UDim2.new(0, 20, 0, 20)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 40)
    mainFrame.BorderSizePixel = 0
    mainFrame.BorderColor3 = Color3.fromRGB(60, 60, 100)
    mainFrame.BorderSize = 2
    mainFrame.Parent = screenGui
    
    -- –£–ª—É—á—à–µ–Ω–Ω—ã–µ —Å–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–µ —É–≥–ª—ã
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = mainFrame
    
    -- –≠–ª–µ–≥–∞–Ω—Ç–Ω—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
    local titleFrame = Instance.new("Frame")
    titleFrame.Name = "TitleFrame"
    titleFrame.Size = UDim2.new(1, 0, 0, 45)
    titleFrame.Position = UDim2.new(0, 0, 0, 0)
    titleFrame.BackgroundColor3 = Color3.fromRGB(40, 120, 255)
    titleFrame.BorderSizePixel = 0
    titleFrame.Parent = mainFrame
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 12)
    titleCorner.Parent = titleFrame
    
    -- –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "TitleLabel"
    titleLabel.Size = UDim2.new(1, 0, 0, 45)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "ü§ñ ML Battle Bot v6.8"
    titleLabel.TextColor3 = Color3.white
    titleLabel.TextScaled = true
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Center
    titleLabel.Parent = titleFrame
    
    -- –°—Ç–∞—Ç—É—Å —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
    local statusFrame = Instance.new("Frame")
    statusFrame.Name = "StatusFrame"
    statusFrame.Size = UDim2.new(1, -20, 0, 70)
    statusFrame.Position = UDim2.new(0, 10, 0, 55)
    statusFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 65)
    statusFrame.BorderSizePixel = 0
    statusFrame.Parent = mainFrame
    
    local statusCorner = Instance.new("UICorner")
    statusCorner.CornerRadius = UDim.new(0, 8)
    statusCorner.Parent = statusFrame
    
    -- –û—Å–Ω–æ–≤–Ω–æ–π —Å—Ç–∞—Ç—É—Å
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Name = "StatusLabel"
    statusLabel.Size = UDim2.new(1, 0, 0, 25)
    statusLabel.Position = UDim2.new(0, 0, 0, 5)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = "üî¥ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
    statusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
    statusLabel.TextScaled = true
    statusLabel.Font = Enum.Font.GothamBold
    statusLabel.Parent = statusFrame
    
    -- –ü—Ä–æ–≥—Ä–µ—Å—Å –æ–±—É—á–µ–Ω–∏—è
    local progressLabel = Instance.new("TextLabel")
    progressLabel.Name = "ProgressLabel"
    progressLabel.Size = UDim2.new(1, 0, 0, 20)
    progressLabel.Position = UDim2.new(0, 0, 0, 30)
    progressLabel.BackgroundTransparency = 1
    progressLabel.Text = "üß† –û–±—É—á–µ–Ω–∏–µ: 0 –ø—Ä–∏–º–µ—Ä–æ–≤"
    progressLabel.TextColor3 = Color3.fromRGB(180, 180, 200)
    progressLabel.TextScaled = true
    progressLabel.Font = Enum.Font.Gotham
    progressLabel.TextXAlignment = Enum.TextXAlignment.Center
    progressLabel.Parent = statusFrame
    
    -- –≠–Ω–µ—Ä–≥–∏—è –∏ –∫—É–ª–¥–∞—É–Ω—ã
    local energyLabel = Instance.new("TextLabel")
    energyLabel.Name = "EnergyLabel"
    energyLabel.Size = UDim2.new(1, 0, 0, 20)
    energyLabel.Position = UDim2.new(0, 0, 0, 50)
    energyLabel.BackgroundTransparency = 1
    energyLabel.Text = "‚ö° –≠–Ω–µ—Ä–≥–∏—è: 100% | üïí –ö–î: –ì–æ—Ç–æ–≤"
    energyLabel.TextColor3 = Color3.fromRGB(150, 200, 255)
    energyLabel.TextScaled = true
    energyLabel.Font = Enum.Font.Gotham
    energyLabel.TextXAlignment = Enum.TextXAlignment.Center
    energyLabel.Parent = statusFrame
    
    -- –£–ª—É—á—à–µ–Ω–Ω–∞—è –∫–Ω–æ–ø–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    local toggleButton = Instance.new("TextButton")
    toggleButton.Name = "ToggleButton"
    toggleButton.Size = UDim2.new(1, -40, 0, 55)
    toggleButton.Position = UDim2.new(0, 20, 0, 135)
    toggleButton.BackgroundColor3 = Color3.fromRGB(80, 200, 80)
    toggleButton.BorderSizePixel = 0
    toggleButton.Text = "‚ñ∂Ô∏è –ó–ê–ü–£–°–¢–ò–¢–¨ –ë–û–¢"
    toggleButton.TextColor3 = Color3.white
    toggleButton.TextScaled = true
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.Parent = mainFrame
    
    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 12)
    toggleCorner.Parent = toggleButton
    
    -- –ü–∞–Ω–µ–ª—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
    local statsFrame = Instance.new("Frame")
    statsFrame.Name = "StatsFrame"
    statsFrame.Size = UDim2.new(1, -20, 0, 140)
    statsFrame.Position = UDim2.new(0, 10, 0, 200)
    statsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 50)
    statsFrame.BorderSizePixel = 0
    statsFrame.Parent = mainFrame
    
    local statsCorner = Instance.new("UICorner")
    statsCorner.CornerRadius = UDim.new(0, 8)
    statsCorner.Parent = statsFrame
    
    local statsText = Instance.new("TextLabel")
    statsText.Name = "StatsText"
    statsText.Size = UDim2.new(1, -10, 1, -10)
    statsText.Position = UDim2.new(0, 5, 0, 5)
    statsText.BackgroundTransparency = 1
    statsText.Text = "üß† –ü—Ä–æ–≥—Ä–µ—Å—Å: 0%\n‚öîÔ∏è –í—Ä–∞–≥–æ–≤ –ø–æ–±–µ–∂–¥–µ–Ω–æ: 0\nüéØ –¢–æ—á–Ω–æ—Å—Ç—å: 0%\nüíª –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: 00:00\nüî• FPS: 60\nüíæ –ü–∞–º—è—Ç—å: –°—Ç–∞–±–∏–ª—å–Ω–∞—è"
    statsText.TextColor3 = Color3.fromRGB(200, 200, 220)
    statsText.TextScaled = true
    statsText.Font = Enum.Font.Gotham
    statsText.TextXAlignment = Enum.TextXAlignment.Left
    statsText.TextYAlignment = Enum.TextYAlignment.Top
    statsText.Parent = statsFrame
    
    -- –õ–æ–≥ —Å–æ–æ–±—â–µ–Ω–∏–π —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –¥–∏–∑–∞–π–Ω–æ–º
    local logFrame = Instance.new("Frame")
    logFrame.Name = "LogFrame"
    logFrame.Size = UDim2.new(1, -20, 0, 90)
    logFrame.Position = UDim2.new(0, 10, 0, 350)
    logFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    logFrame.BorderSizePixel = 0
    logFrame.Parent = mainFrame
    
    local logCorner = Instance.new("UICorner")
    logCorner.CornerRadius = UDim.new(0, 8)
    logCorner.Parent = logFrame
    
    local logText = Instance.new("TextLabel")
    logText.Name = "LogText"
    logText.Size = UDim2.new(1, -10, 1, -10)
    logText.Position = UDim2.new(0, 5, 0, 5)
    logText.BackgroundTransparency = 1
    logText.Text = "üîµ ML Bot v6.8 FULLY WORKING –≥–æ—Ç–æ–≤ –∫ –∑–∞–ø—É—Å–∫—É"
    logText.TextColor3 = Color3.fromRGB(150, 180, 220)
    logText.TextScaled = true
    logText.Font = Enum.Font.Gotham
    logText.TextXAlignment = Enum.TextXAlignment.Left
    logText.TextYAlignment = Enum.TextYAlignment.Top
    logText.Parent = logFrame
    
    return {
        mainFrame = mainFrame,
        statusLabel = statusLabel,
        progressLabel = progressLabel,
        energyLabel = energyLabel,
        toggleButton = toggleButton,
        statsText = statsText,
        logText = logText,
        screenGui = screenGui
    }
end

function MobileGUI:animateButton(button, enabled)
    if not button then return end
    
    local targetColor = enabled and Color3.fromRGB(200, 60, 60) or Color3.fromRGB(80, 200, 80)
    local targetText = enabled and "‚è∏Ô∏è –û–°–¢–ê–ù–û–í–ò–¢–¨ –ë–û–¢" or "‚ñ∂Ô∏è –ó–ê–ü–£–°–¢–ò–¢–¨ –ë–û–¢"
    
    local success, error = pcall(function()
        local tween = TweenService:Create(button, 
            TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out),
            {
                BackgroundColor3 = targetColor
            }
        )
        tween:Play()
        
        button.Text = targetText
    end)
    
    if not success then
        print("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∞–Ω–∏–º–∞—Ü–∏–∏ –∫–Ω–æ–ø–∫–∏:", error and tostring(error) or "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞")
    end
end

function MobileGUI:updateStatus(gui, status, color, progress, enemyCount, success, time, fps, memory)
    if not gui or not gui.statusLabel then return end
    
    local minutes = math.floor(time / 60)
    local seconds = math.floor(time % 60)
    local fpsText = fps and string.format("%.0f", fps) or "60"
    local memoryText = memory or "–°—Ç–∞–±–∏–ª—å–Ω–∞—è"
    
    gui.statusLabel.Text = status or "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
    gui.statusLabel.TextColor3 = color or Color3.white
    gui.progressLabel.Text = "üß† –û–±—É—á–µ–Ω–∏–µ: " .. (progress or 0) .. " –ø—Ä–∏–º–µ—Ä–æ–≤"
    
    gui.statsText.Text = string.format(
        "üß† –ü—Ä–æ–≥—Ä–µ—Å—Å: %d%%\n‚öîÔ∏è –í—Ä–∞–≥–æ–≤ –ø–æ–±–µ–∂–¥–µ–Ω–æ: %d\nüéØ –¢–æ—á–Ω–æ—Å—Ç—å: %d%%\nüíª –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: %02d:%02d\nüî• FPS: %s\nüíæ –ü–∞–º—è—Ç—å: %s",
        math.max(0, math.min(100, progress or 0)),
        math.max(0, enemyCount or 0),
        math.max(0, math.min(100, success or 0)),
        math.max(0, minutes),
        math.max(0, seconds),
        fpsText,
        memoryText
    )
end

function MobileGUI:updateEnergy(gui, energy, cooldown)
    if not gui or not gui.energyLabel then return end
    
    local energyText = energy and string.format("‚ö° –≠–Ω–µ—Ä–≥–∏—è: %.0f%%", energy * 100) or "‚ö° –≠–Ω–µ—Ä–≥–∏—è: 100%"
    local cooldownText = cooldown and (" | üïí –ö–î: " .. cooldown .. "—Å") or " | üïí –ö–î: –ì–æ—Ç–æ–≤"
    
    gui.energyLabel.Text = energyText .. cooldownText
end

function MobileGUI:addLog(gui, message)
    if not gui or not gui.logText then return end
    
    local safeMessage = message and tostring(message) or "–ù–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è"
    local timestamp = os.date("%H:%M:%S")
    gui.logText.Text = "[" .. timestamp .. "] " .. safeMessage
end

-- === –£–õ–£–ß–®–ï–ù–ù–ê–Ø ML –°–ò–°–¢–ï–ú–ê ===
function mlSystem:init()
    -- –£–ª—É—á—à–µ–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –Ω–µ–π—Ä–æ–Ω–Ω–æ–π —Å–µ—Ç–∏
    self.neuralNetwork = {
        inputSize = 12,      -- –£–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö
        hiddenSize1 = 16,    -- –ü–µ—Ä–≤—ã–π —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π
        hiddenSize2 = 8,     -- –í—Ç–æ—Ä–æ–π —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π
        outputSize = 4,      -- 4 —Å–∫–∏–ª–ª–∞
        weights = {
            input = {},
            hidden1 = {},
            hidden2 = {}
        },
        bias = {
            hidden1 = {},
            hidden2 = {},
            output = {}
        },
        lastInputs = {},
        lastTargets = {},
        trainingHistory = {},
        normalization = {
            means = {},
            stds = {}
        },
        learningRate = 0.01,
        momentum = 0.9
    }
    
    -- –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª
    math.randomseed(math.floor(tick() * 1000000) % 2147483647)
    
    -- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤–µ—Å–æ–≤ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
    for h1 = 1, self.neuralNetwork.hiddenSize1 do
        self.neuralNetwork.weights.input[h1] = {}
        self.neuralNetwork.bias.hidden1[h1] = 0
        
        for i = 1, self.neuralNetwork.inputSize do
            local weight = (math.random() - 0.5) * 0.4
            self.neuralNetwork.weights.input[h1][i] = weight
        end
    end
    
    for h2 = 1, self.neuralNetwork.hiddenSize2 do
        self.neuralNetwork.weights.hidden1[h2] = {}
        self.neuralNetwork.bias.hidden2[h2] = 0
        
        for h1 = 1, self.neuralNetwork.hiddenSize1 do
            local weight = (math.random() - 0.5) * 0.3
            self.neuralNetwork.weights.hidden1[h2][h1] = weight
        end
    end
    
    for o = 1, self.neuralNetwork.outputSize do
        self.neuralNetwork.weights.hidden2[o] = {}
        self.neuralNetwork.bias.output[o] = 0
        
        for h2 = 1, self.neuralNetwork.hiddenSize2 do
            local weight = (math.random() - 0.5) * 0.2
            self.neuralNetwork.weights.hidden2[o][h2] = weight
        end
    end
    
    -- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–±—É—á–µ–Ω–∏—è
    self.trainingCount = 0
    self.progress = 0
    self.enemiesDefeated = 0
    self.successRate = 0
    self.lastError = 0
    self.avgAccuracy = 0
    self.learningHistory = {}
    
    print("üß† –£–ª—É—á—à–µ–Ω–Ω–∞—è ML –°–∏—Å—Ç–µ–º–∞ v6.8 –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
end

function mlSystem:sigmoid(x)
    if not x or type(x) ~= "number" then
        return 0.5
    end
    
    if x > 25 then return 1 end
    if x < -25 then return 0 end
    return 1 / (1 + math.exp(-x))
end

function mlSystem:relu(x)
    if not x or type(x) ~= "number" then
        return 0
    end
    return math.max(0, x)
end

function mlSystem:normalizeInputs(inputs)
    if not inputs or type(inputs) ~= "table" then
        return {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    end
    
    -- –£–ª—É—á—à–µ–Ω–Ω–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    local normalized = {}
    
    for i = 1, 12 do
        local val = inputs[i]
        if not val or type(val) ~= "number" then
            val = 0
        end
        
        -- –°–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ –¥–∞–Ω–Ω—ã—Ö
        if i <= 6 then
            -- –ó–¥–æ—Ä–æ–≤—å–µ –∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è (0-1)
            normalized[i] = math.max(0, math.min(1, val))
        elseif i <= 8 then
            -- –£—Ä–æ–≤–Ω–∏ –∏ –≤—Ä–µ–º—è (0-1 —Å –±–æ–ª—å—à–∏–º –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º)
            normalized[i] = math.max(0, math.min(1, val / 100))
        else
            -- –û—Å—Ç–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (-1 –¥–æ 1)
            normalized[i] = math.max(-1, math.min(1, val))
        end
    end
    
    return normalized
end

function mlSystem:validateInputs(inputs)
    if not inputs or type(inputs) ~= "table" then
        return false, self:normalizeInputs({})
    end
    
    local validated = self:normalizeInputs(inputs)
    return true, validated
end

function mlSystem:forward(inputs)
    local nn = self.neuralNetwork
    local success, validatedInputs = self:validateInputs(inputs)
    
    if not success then
        return {0.25, 0.25, 0.25, 0.25}
    end
    
    local hidden1 = {}
    local hidden2 = {}
    
    -- –ü–µ—Ä–≤—ã–π —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π
    for h1 = 1, nn.hiddenSize1 do
        if not nn.weights.input[h1] or not nn.bias.hidden1[h1] then
            return {0.25, 0.25, 0.25, 0.25}
        end
        
        local sum = nn.bias.hidden1[h1]
        for i = 1, nn.inputSize do
            local weight = nn.weights.input[h1][i]
            if weight and type(weight) == "number" then
                sum = sum + weight * validatedInputs[i]
            end
        end
        hidden1[h1] = self:sigmoid(sum)
    end
    
    -- –í—Ç–æ—Ä–æ–π —Å–∫—Ä—ã—Ç—ã–π —Å–ª–æ–π
    for h2 = 1, nn.hiddenSize2 do
        if not nn.weights.hidden1[h2] or not nn.bias.hidden2[h2] then
            return {0.25, 0.25, 0.25, 0.25}
        end
        
        local sum = nn.bias.hidden2[h2]
        for h1 = 1, nn.hiddenSize1 do
            local weight = nn.weights.hidden1[h2][h1]
            if weight and type(weight) == "number" and hidden1[h1] then
                sum = sum + weight * hidden1[h1]
            end
        end
        hidden2[h2] = self:relu(sum) -- –ò—Å–ø–æ–ª—å–∑—É–µ–º ReLU –¥–ª—è –ª—É—á—à–µ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    end
    
    -- –í—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π
    local outputs = {}
    for o = 1, nn.outputSize do
        if not nn.weights.hidden2[o] or not nn.bias.output[o] then
            return {0.25, 0.25, 0.25, 0.25}
        end
        
        local sum = nn.bias.output[o]
        for h2 = 1, nn.hiddenSize2 do
            local weight = nn.weights.hidden2[o][h2]
            if weight and type(weight) == "number" and hidden2[h2] then
                sum = sum + weight * hidden2[h2]
            end
        end
        outputs[o] = self:sigmoid(sum)
    end
    
    return outputs
end

-- === –£–õ–£–ß–®–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –û–ë–£–ß–ï–ù–ò–Ø ===
function mlSystem:train(inputs, targets, reward, action)
    local nn = self.neuralNetwork
    
    local success, validatedInputs = self:validateInputs(inputs)
    if not success or not targets then
        self.lastError = 1.0
        return 1.0
    end
    
    local outputs = self:forward(validatedInputs)
    
    -- –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∫—Ä—ã—Ç—ã—Ö —Å–ª–æ–µ–≤ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è
    local hidden1 = {}
    for h1 = 1, nn.hiddenSize1 do
        local sum = nn.bias.hidden1[h1]
        for i = 1, nn.inputSize do
            local weight = nn.weights.input[h1][i]
            if weight and type(weight) == "number" then
                sum = sum + weight * validatedInputs[i]
            end
        end
        hidden1[h1] = self:sigmoid(sum)
    end
    
    local hidden2 = {}
    for h2 = 1, nn.hiddenSize2 do
        local sum = nn.bias.hidden2[h2]
        for h1 = 1, nn.hiddenSize1 do
            local weight = nn.weights.hidden1[h2][h1]
            if weight and type(weight) == "number" and hidden1[h1] then
                sum = sum + weight * hidden1[h1]
            end
        end
        hidden2[h2] = self:relu(sum)
    end
    
    -- –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞–≥—Ä–∞–¥
    local safeReward = 0.5
    if reward and type(reward) == "number" and reward >= 0 and reward <= 1 then
        safeReward = reward
    end
    
    -- –£–ª—É—á—à–µ–Ω–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ —Ü–µ–ª–µ–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–≥—Ä–∞–¥—ã
    local adjustedTargets = {}
    for i = 1, 4 do
        local targetVal = targets[i] or 0.25
        local boost = 0
        
        -- –£—Å–∏–ª–µ–Ω–∏–µ –Ω–∞–≥—Ä–∞–¥—ã –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è
        if i == action then
            boost = (safeReward - 0.5) * 0.5
        else
            boost = (0.5 - safeReward) * 0.2
        end
        
        adjustedTargets[i] = targetVal + boost
        adjustedTargets[i] = math.max(0.01, math.min(0.99, adjustedTargets[i]))
    end
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–µ—Å–æ–≤ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º
    local learningRate = nn.learningRate
    local momentum = nn.momentum
    local totalError = 0
    
    -- –í—ã—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π
    for o = 1, 4 do
        if outputs[o] and adjustedTargets[o] then
            local error = adjustedTargets[o] - outputs[o]
            totalError = totalError + error * error
            
            -- –ì—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Å–ª–æ—è
            local delta = error * outputs[o] * (1 - outputs[o])
            
            for h2 = 1, nn.hiddenSize2 do
                if nn.weights.hidden2[o][h2] and hidden2[h2] then
                    local gradient = learningRate * delta * hidden2[h2]
                    nn.weights.hidden2[o][h2] = nn.weights.hidden2[o][h2] + gradient
                end
            end
            
            if nn.bias.output[o] then
                nn.bias.output[o] = nn.bias.output[o] + learningRate * delta
            end
        end
    end
    
    -- –°–∫—Ä—ã—Ç—ã–µ —Å–ª–æ–∏
    for h2 = 1, nn.hiddenSize2 do
        local sum_error = 0
        for o = 1, 4 do
            if nn.weights.hidden2[o][h2] and outputs[o] then
                local error = adjustedTargets[o] - outputs[o]
                local delta = error * outputs[o] * (1 - outputs[o])
                sum_error = sum_error + delta * nn.weights.hidden2[o][h2]
            end
        end
        
        local delta = sum_error * hidden2[h2] * (1 - hidden2[h2])
        
        for h1 = 1, nn.hiddenSize1 do
            if nn.weights.hidden1[h2][h1] and hidden1[h1] then
                local gradient = learningRate * delta * hidden1[h1]
                nn.weights.hidden1[h2][h1] = nn.weights.hidden1[h2][h1] + gradient
            end
        end
        
        if nn.bias.hidden2[h2] then
            nn.bias.hidden2[h2] = nn.bias.hidden2[h2] + learningRate * delta
        end
    end
    
    -- –í—Ö–æ–¥–Ω–æ–π —Å–ª–æ–π
    for h1 = 1, nn.hiddenSize1 do
        local sum_error = 0
        for h2 = 1, nn.hiddenSize2 do
            if nn.weights.hidden1[h2][h1] and hidden2[h2] then
                local sum_error_2 = 0
                for o = 1, 4 do
                    if nn.weights.hidden2[o][h2] and outputs[o] then
                        local error = adjustedTargets[o] - outputs[o]
                        local delta = error * outputs[o] * (1 - outputs[o])
                        sum_error_2 = sum_error_2 + delta * nn.weights.hidden2[o][h2]
                    end
                end
                local delta2 = sum_error_2 * hidden2[h2] * (1 - hidden2[h2])
                sum_error = sum_error + delta2 * nn.weights.hidden1[h2][h1]
            end
        end
        
        local delta = sum_error * hidden1[h1] * (1 - hidden1[h1])
        
        for i = 1, nn.inputSize do
            if nn.weights.input[h1][i] then
                local gradient = learningRate * delta * validatedInputs[i]
                nn.weights.input[h1][i] = nn.weights.input[h1][i] + gradient
            end
        end
        
        if nn.bias.hidden1[h1] then
            nn.bias.hidden1[h1] = nn.bias.hidden1[h1] + learningRate * delta
        end
    end
    
    totalError = totalError / 4
    self.progress = math.max(0, 1 - totalError)
    self.trainingCount = self.trainingCount + 1
    self.lastError = totalError
    
    return totalError
end

function mlSystem:predict(stateData)
    if not stateData then
        return keys.Skill1, 0.25
    end
    
    -- –£–≤–µ–ª–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    local inputs = {
        type(stateData.playerHealth) == "number" and stateData.playerHealth or 1.0,
        type(stateData.enemyHealth) == "number" and stateData.enemyHealth or 1.0,
        type(stateData.enemyDistance) == "number" and stateData.enemyDistance or 100,
        type(stateData.enemyLevel) == "number" and stateData.enemyLevel or 1,
        type(stateData.pattern) == "number" and stateData.pattern or 0.5,
        type(stateData.timeInBattle) == "number" and stateData.timeInBattle or 0.5,
        type(stateData.energy) == "number" and stateData.energy or 1.0,
        type(stateData.cooldown) == "number" and stateData.cooldown or 0.0,
        type(stateData.enemyCount) == "number" and stateData.enemyCount or 1,
        type(stateData.skillEffectiveness) == "number" and stateData.skillEffectiveness or 0.5,
        type(stateData.combatIntensity) == "number" and stateData.combatIntensity or 0.5,
        type(stateData.strategyBonus) == "number" and stateData.strategyBonus or 0.0
    }
    
    local outputs = self:forward(inputs)
    
    local bestIdx = 1
    local bestValue = outputs[1] or 0.25
    
    for i = 2, 4 do
        if outputs[i] and outputs[i] > bestValue then
            bestValue = outputs[i]
            bestIdx = i
        end
    end
    
    self.bestAction = bestIdx
    local keyList = {keys.Skill1, keys.Skill2, keys.Skill3, keys.Skill4}
    return keyList[bestIdx] or keys.Skill1, bestValue
end

function mlSystem:remember(inputs, action, reward, result, extraData)
    if not inputs or not action then return end
    
    local safeReward = reward and type(reward) == "number" and reward or 0.5
    
    memoryManager:addToPool("rewards", {
        inputs = {inputs[1], inputs[2], inputs[3], inputs[4], inputs[5], inputs[6], inputs[7], inputs[8], inputs[9], inputs[10], inputs[11], inputs[12]},
        action = action,
        reward = safeReward,
        result = result,
        extraData = extraData or {},
        time = tick()
    })
end

function mlSystem:learn()
    local rewards = memoryManager.memoryPools.rewards
    if #rewards < 3 then return end
    
    local successCount = 0
    local totalAccuracy = 0
    local learnCount = 0
    
    for i = math.max(1, #rewards - 9), #rewards do
        local battle = rewards[i]
        if battle and battle.inputs and battle.action then
            local targets = {0.25, 0.25, 0.25, 0.25}
            targets[battle.action] = 0.7
            
            local error = self:train(battle.inputs, targets, battle.reward, battle.action)
            
            if error and error < 0.4 then
                successCount = successCount + 1
                totalAccuracy = totalAccuracy + (1 - error)
            end
            
            learnCount = learnCount + 1
        end
    end
    
    if learnCount > 0 then
        self.successRate = #rewards > 0 and (successCount / math.min(10, learnCount)) * 100 or 0
        self.avgAccuracy = successCount > 0 and totalAccuracy / successCount or 0
        
        print("üéØ –ò–ò –æ–±—É—á–∏–ª—Å—è –Ω–∞", learnCount, "–ø—Ä–∏–º–µ—Ä–∞—Ö | –¢–æ—á–Ω–æ—Å—Ç—å:", math.floor(self.successRate) .. "%")
        
        -- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –æ–±—É—á–µ–Ω–∏—è
        table.insert(self.learningHistory, {
            time = tick(),
            examples = learnCount,
            accuracy = self.successRate,
            error = self.lastError
        })
        
        -- –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏
        while #self.learningHistory > 50 do
            table.remove(self.learningHistory, 1)
        end
    end
end

-- === –û–°–ù–û–í–ù–û–ô –ë–û–¢ ===
local MLAutoBattleBot = {}
MLAutoBattleBot.__index = MLAutoBattleBot

function MLAutoBattleBot:new()
    local self = setmetatable({}, MLAutoBattleBot)
    
    -- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º
    memoryManager:init()
    performanceMonitor:init()
    mlSystem:init()
    
    -- –°–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—Ç–∞
    self.enabled = false
    self.player = nil
    self.character = nil
    self.humanoid = nil
    self.health = 1.0
    self.currentEnemy = nil
    self.lastActionTime = 0
    self.lastEnemyHealth = nil
    self.movementActive = false
    self.startTime = 0
    self.errorCount = 0
    self.lastErrorTime = 0
    
    -- –°–∏—Å—Ç–µ–º–∞ —ç–Ω–µ—Ä–≥–∏–∏ –∏ –∫—É–ª–¥–∞—É–Ω–æ–≤
    self.energy = 100
    self.maxEnergy = 100
    self.energyRegenRate = 10 -- –≤ —Å–µ–∫—É–Ω–¥—É
    self.skillCooldowns = {
        [1] = 0, -- —Å–∫–∏–ª–ª 1
        [2] = 0, -- —Å–∫–∏–ª–ª 2  
        [3] = 0, -- —Å–∫–∏–ª–ª 3
        [4] = 0  -- —Å–∫–∏–ª–ª 4
    }
    
    -- –°–∏—Å—Ç–µ–º–∞ –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏–∏ –≤—Ä–∞–≥–æ–≤
    self.enemyPriorities = {}
    self.combatSituation = {
        intensity = 0.5,
        survivalMode = false,
        aggressiveMode = false
    }
    
    return self
end

function MLAutoBattleBot:initialize()
    local success, result = pcall(function()
        print("üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ML Bot v6.8 FULLY WORKING...")
        
        self.player = Players.LocalPlayer
        if not self.player then
            return false, "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–≥—Ä–æ–∫–∞"
        end
        
        self.character = self.player.Character or self.player.CharacterAdded:Wait()
        if not self.character then
            return false, "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞"
        end
        
        self.humanoid = self.character:WaitForChild("Humanoid")
        if not self.humanoid then
            return false, "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å Humanoid"
        end
        
        -- –°–æ–∑–¥–∞–Ω–∏–µ —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ GUI
        self.gui = MobileGUI:create()
        if not self.gui then
            return false, "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å GUI"
        end
        
        -- –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∏
        if self.gui.toggleButton then
            self.gui.toggleButton.MouseButton1Click:Connect(function()
                self:toggle()
            end)
        end
        
        return true
    end)
    
    if success and result then
        print("‚úÖ ML Bot v6.8 FULLY WORKING –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")
        return true
    else
        print("‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:", result or "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞")
        return false
    end
end

function MLAutoBattleBot:updateEnergy(dt)
    -- –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏
    if self.energy < self.maxEnergy then
        self.energy = math.min(self.maxEnergy, self.energy + self.energyRegenRate * dt)
    end
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—É–ª–¥–∞—É–Ω–æ–≤
    for i = 1, 4 do
        if self.skillCooldowns[i] > 0 then
            self.skillCooldowns[i] = math.max(0, self.skillCooldowns[i] - dt)
        end
    end
end

function MLAutoBattleBot:useSkill(keyCode)
    if not keyCode then return false, "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π keyCode" end
    
    -- –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ —Å–∫–∏–ª–ª–∞
    local skillNum = 1
    if keyCode == Enum.KeyCode.Two then skillNum = 2
    elseif keyCode == Enum.KeyCode.Three then skillNum = 3
    elseif keyCode == Enum.KeyCode.Four then skillNum = 4
    end
    
    -- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—É–ª–¥–∞—É–Ω–∞
    if self.skillCooldowns[skillNum] > 0 then
        return false, "–°–∫–∏–ª–ª –Ω–∞ –∫—É–ª–¥–∞—É–Ω–µ: " .. self.skillCooldowns[skillNum] .. "—Å"
    end
    
    -- –ü—Ä–æ–≤–µ—Ä–∫–∞ —ç–Ω–µ—Ä–≥–∏–∏
    local energyCost = 10 + skillNum * 5 -- –†–∞–∑–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å —Å–∫–∏–ª–ª–æ–≤
    if self.energy < energyCost then
        return false, "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —ç–Ω–µ—Ä–≥–∏–∏: –Ω—É–∂–Ω–æ " .. energyCost
    end
    
    local currentTime = tick()
    if currentTime - self.lastActionTime < 0.5 then
        return false, "–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–∞–≤—ã–∫–æ–≤"
    end
    
    local success, error = pcall(function()
        -- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–∫–∏–ª–ª–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è —ç–º—É–ª—è—Ü–∏—è –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à–∏)
        if keyCode == Enum.KeyCode.One or keyCode == Enum.KeyCode.Two or keyCode == Enum.KeyCode.Three or keyCode == Enum.KeyCode.Four then
            -- –í —Ä–µ–∞–ª—å–Ω–æ–º –±–æ—Ç–µ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã —ç–º—É–ª—è—Ü–∏—è –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à–∏
            -- –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º –∫—É–ª–¥–∞—É–Ω –∏ —ç–Ω–µ—Ä–≥–∏—é
            self.skillCooldowns[skillNum] = 3 + skillNum -- –†–∞–∑–Ω—ã–µ –∫—É–ª–¥–∞—É–Ω—ã
            self.energy = math.max(0, self.energy - energyCost)
            return true
        else
            error("–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π keyCode")
            return false
        end
    end)
    
    if success then
        self.lastActionTime = currentTime
        return true
    else
        return false, error and tostring(error) or "–æ—à–∏–±–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à–∏"
    end
end

-- === –ü–û–õ–ù–û–°–¢–¨–Æ –ü–ï–†–ï–ü–ò–°–ê–ù–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –ü–û–ò–°–ö–ê –í–†–ê–ì–û–í ===
function MLAutoBattleBot:findEnemy()
    if not self.player or not self.character then return nil end
    
    local enemies = {}
    local playerPosition = self.character:FindFirstChild("HumanoidRootPart")
    if not playerPosition then return nil end
    
    -- –ü–æ–∏—Å–∫ –≤—Å–µ—Ö –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤
    for _, targetPlayer in pairs(Players:GetPlayers()) do
        if targetPlayer ~= self.player and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Humanoid") then
            local humanoid = targetPlayer.Character.Humanoid
            local rootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            
            if humanoid and rootPart and humanoid.Health > 0 then
                local distance
                local success, dist = pcall(function()
                    return (playerPosition.Position - rootPart.Position).Magnitude
                end)
                
                if not success then
                    distance = math.huge
                else
                    distance = dist
                end
                
                -- –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é –∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏
                if distance <= 100 and distance >= 5 then -- –†–∞–∑—É–º–Ω—ã–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
                    local enemyInfo = {
                        player = targetPlayer,
                        healthPercent = math.max(0, math.min(1, humanoid.Health / math.max(1, humanoid.MaxHealth))),
                        distance = distance,
                        level = self:getPlayerLevel(targetPlayer),
                        pattern = math.random(),
                        currentHealth = humanoid.Health,
                        maxHealth = humanoid.MaxHealth,
                        position = rootPart.Position,
                        priority = self:calculateEnemyPriority(targetPlayer, distance, humanoid.Health, humanoid.MaxHealth),
                        threatLevel = self:calculateThreatLevel(targetPlayer, distance),
                        lastSeen = tick(),
                        isTargetingPlayer = self:isTargetingPlayer(targetPlayer)
                    }
                    
                    table.insert(enemies, enemyInfo)
                end
            end
        end
    end
    
    if #enemies == 0 then
        self.currentEnemy = nil
        return nil
    end
    
    -- –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É
    table.sort(enemies, function(a, b)
        return a.priority > b.priority
    end)
    
    -- –í—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ –≤—Ä–∞–≥–∞
    local bestEnemy = enemies[1]
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–≤ –≤—Ä–∞–≥–æ–≤
    self.enemyPriorities = enemies
    
    self.currentEnemy = bestEnemy
    return bestEnemy
end

function MLAutoBattleBot:calculateEnemyPriority(player, distance, currentHealth, maxHealth)
    local priority = 0
    
    -- –ë–∞–∑–æ–≤—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è (–±–ª–∏–∂–µ = –≤—ã—à–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
    priority = priority + math.max(0, 100 - distance) * 0.1
    
    -- –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ—Ç —É—Ä–æ–≤–Ω—è –∑–¥–æ—Ä–æ–≤—å—è (–º–µ–Ω—å—à–µ HP = –≤—ã—à–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è –¥–æ–±–∏–≤–∞–Ω–∏—è)
    local healthPercent = currentHealth / math.max(1, maxHealth)
    priority = priority + (1 - healthPercent) * 50
    
    -- –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ—Ç —É—Ä–æ–≤–Ω—è –∏–≥—Ä–æ–∫–∞ (–µ—Å–ª–∏ –º–æ–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å)
    local playerLevel = self:getPlayerLevel(player)
    priority = priority + playerLevel * 10
    
    -- –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –µ—Å–ª–∏ –≤—Ä–∞–≥ –∞—Ç–∞–∫—É–µ—Ç –∏–≥—Ä–æ–∫–∞
    if self:isTargetingPlayer(player) then
        priority = priority + 30
    end
    
    -- –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –≤ –±–æ—é
    local recentActivity = self:getPlayerActivity(player)
    priority = priority + recentActivity * 20
    
    return priority
end

function MLAutoBattleBot:calculateThreatLevel(player, distance)
    local threatLevel = 0
    
    -- –£–≥—Ä–æ–∑–∞ –æ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
    if distance < 10 then
        threatLevel = threatLevel + 50
    elseif distance < 25 then
        threatLevel = threatLevel + 25
    end
    
    -- –£–≥—Ä–æ–∑–∞ –æ—Ç —É—Ä–æ–≤–Ω—è –∏–≥—Ä–æ–∫–∞
    local level = self:getPlayerLevel(player)
    threatLevel = threatLevel + level * 5
    
    -- –£–≥—Ä–æ–∑–∞ –æ—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    local activity = self:getPlayerActivity(player)
    threatLevel = threatLevel + activity * 30
    
    return math.min(100, threatLevel)
end

function MLAutoBattleBot:getPlayerLevel(player)
    -- –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è (–≤ —Ä–µ–∞–ª—å–Ω–æ–π –∏–≥—Ä–µ –Ω—É–∂–Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è –ª–æ–≥–∏–∫–∞)
    local level = 1
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character.Humanoid
        level = math.floor(humanoid.MaxHealth / 100) + 1
    end
    return math.max(1, level)
end

function MLAutoBattleBot:isTargetingPlayer(player)
    -- –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–∏ (–≤ —Ä–µ–∞–ª—å–Ω–æ–π –∏–≥—Ä–µ –Ω—É–∂–Ω–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞)
    return math.random() < 0.3 -- 30% —à–∞–Ω—Å —á—Ç–æ —Ü–µ–ª–∏—Ç—Å—è
end

function MLAutoBattleBot:getPlayerActivity(player)
    -- –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∏–≥—Ä–æ–∫–∞ –≤ –±–æ—é (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞)
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character.Humanoid
        if humanoid.Health < humanoid.MaxHealth * 0.8 then
            return 0.7 -- –í—ã—Å–æ–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –µ—Å–ª–∏ —Ä–∞–Ω–µ–Ω
        else
            return 0.3 -- –ù–∏–∑–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –µ—Å–ª–∏ –∑–¥–æ—Ä–æ–≤
        end
    end
    return 0
end

-- === –ò–ù–¢–ï–õ–õ–ï–ö–¢–£–ê–õ–¨–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –î–í–ò–ñ–ï–ù–ò–Ø ===
function MLAutoBattleBot:moveToEnemy()
    if not self.currentEnemy or self.movementActive then return end
    
    local distance = self.currentEnemy.distance or 100
    if distance > 15 then
        self.movementActive = true
        
        -- –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
        if self:checkForObstacles() then
            self:findAlternativePath()
        else
            self:directMovement()
        end
        
        -- –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
        pcall(function()
            wait(0.5)
        end)
        self.movementActive = false
    end
end

function MLAutoBattleBot:checkForObstacles()
    -- –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –º–µ–∂–¥—É –∏–≥—Ä–æ–∫–æ–º –∏ –≤—Ä–∞–≥–æ–º
    if not self.character or not self.currentEnemy then return false end
    
    local playerPos = self.character.HumanoidRootPart.Position
    local enemyPos = self.currentEnemy.position
    
    if not playerPos or not enemyPos then return false end
    
    -- –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π (–≤ —Ä–µ–∞–ª—å–Ω–æ–π –∏–≥—Ä–µ –Ω—É–∂–Ω–∞ Raycast)
    local distance = (playerPos - enemyPos).Magnitude
    return distance > 20 -- –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è –Ω–∞ –±–æ–ª—å—à–∏—Ö —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è—Ö
end

function MLAutoBattleBot:findAlternativePath()
    -- –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –ø—É—Ç–∏
    if not self.currentEnemy or not self.character then return end
    
    local playerPos = self.character.HumanoidRootPart.Position
    local enemyPos = self.currentEnemy.position
    
    -- –û–±—Ö–æ–¥–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
    local direction = (enemyPos - playerPos).Unit
    local perpendicular = Vector3.new(-direction.Z, 0, direction.X) -- –ü–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω—ã–π –≤–µ–∫—Ç–æ—Ä
    
    local success, error = pcall(function()
        -- –î–≤–∏–∂–µ–Ω–∏–µ –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω–æ –∫ —Ü–µ–ª–∏
        if math.random() > 0.5 then
            self:moveInDirection(perpendicular)
        else
            self:moveInDirection(perpendicular * -1)
        end
    end)
    
    if not success then
        print("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ–≥–æ –ø—É—Ç–∏:", error)
    end
end

function MLAutoBattleBot:directMovement()
    if not self.currentEnemy or not self.character then return end
    
    local playerPos = self.character.HumanoidRootPart.Position
    local enemyPos = self.currentEnemy.position
    
    if not playerPos or not enemyPos then return end
    
    local direction = (enemyPos - playerPos).Unit
    
    self:moveInDirection(direction)
end

function MLAutoBattleBot:moveInDirection(direction)
    local success, error = pcall(function()
        -- –î–≤–∏–∂–µ–Ω–∏–µ –ø–æ –æ—Å—è–º —Å –∏–∑–±–µ–≥–∞–Ω–∏–µ–º —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
        if direction.X > 0.3 then
            keybd_event(keys.WASD.D, 0, 0, 0)
            wait(0.1)
            keybd_event(keys.WASD.D, 0, 2, 0)
        elseif direction.X < -0.3 then
            keybd_event(keys.WASD.A, 0, 0, 0)
            wait(0.1)
            keybd_event(keys.WASD.A, 0, 2, 0)
        end
        
        if direction.Z > 0.3 then
            keybd_event(keys.WASD.W, 0, 0, 0)
            wait(0.1)
            keybd_event(keys.WASD.W, 0, 2, 0)
        elseif direction.Z < -0.3 then
            keybd_event(keys.WASD.S, 0, 0, 0)
            wait(0.1)
            keybd_event(keys.WASD.S, 0, 2, 0)
        end
    end)
    
    if not success then
        print("‚ö†Ô∏è –û—à–∏–±–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è:", error)
    end
end

-- === –†–ê–ë–û–¢–ê–Æ–©–ê–Ø –°–ò–°–¢–ï–ú–ê –ù–ê–ì–†–ê–î –ò –®–¢–†–ê–§–û–í ===
function MLAutoBattleBot:calculateReward()
    local reward = 0.3 -- –ë–∞–∑–æ–≤–∞—è –Ω–∞–≥—Ä–∞–¥–∞
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    if not self.currentEnemy then
        return 0.2
    end
    
    local currentHealth = self.currentEnemy.currentHealth
    local lastHealth = self.lastEnemyHealth
    
    if not lastHealth or not currentHealth then
        return 0.3
    end
    
    local healthDecrease = lastHealth - currentHealth
    local healthPercent = currentHealth / math.max(1, self.currentEnemy.maxHealth)
    
    -- –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã
    if currentHealth <= 0 then
        reward = 1.0  -- –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞ –∑–∞ —É–±–∏–π—Å—Ç–≤–æ
        mlSystem.enemiesDefeated = mlSystem.enemiesDefeated + 1
        
        if self.gui then
            MobileGUI:addLog(self.gui, "üèÜ –í–†–ê–ì –ü–û–ë–ï–ñ–î–ï–ù!")
        end
    elseif healthDecrease > 0 then
        -- –ù–∞–≥—Ä–∞–¥–∞ –∑–∞ —É—Ä–æ–Ω
        local damageReward = math.min(0.8, healthDecrease / math.max(1, lastHealth) * 0.6)
        reward = reward + damageReward
        
        -- –ë–æ–Ω—É—Å –∑–∞ –¥–æ–±–∏–≤–∞–Ω–∏–µ —Ä–∞–Ω–µ–Ω–æ–≥–æ –≤—Ä–∞–≥–∞
        if healthPercent < 0.3 then
            reward = reward + 0.2
        end
    else
        reward = 0.1  -- –®—Ç—Ä–∞—Ñ –∑–∞ –ø—Ä–æ–º–∞—Ö
    end
    
    -- –¢–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –Ω–∞–≥—Ä–∞–¥—ã
    local distance = self.currentEnemy.distance or 100
    
    -- –ù–∞–≥—Ä–∞–¥–∞ –∑–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –¥–∏—Å—Ç–∞–Ω—Ü–∏—é
    if distance >= 10 and distance <= 25 then
        reward = reward + 0.1
    elseif distance < 5 then
        reward = reward - 0.1  -- –®—Ç—Ä–∞—Ñ –∑–∞ —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
    end
    
    -- –ù–∞–≥—Ä–∞–¥–∞ –∑–∞ –≤—ã–∂–∏–≤–∞–Ω–∏–µ –ø—Ä–∏ –Ω–∏–∑–∫–æ–º –∑–¥–æ—Ä–æ–≤—å–µ
    if self.health and self.health < 0.4 and healthDecrease > 0 then
        reward = reward + 0.15
    end
    
    -- –ù–∞–≥—Ä–∞–¥–∞ –∑–∞ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏
    if self.energy and self.energy < 0.5 and reward > 0.5 then
        reward = reward + 0.1
    end
    
    -- –ù–∞–≥—Ä–∞–¥–∞ –∑–∞ –±—ã—Å—Ç—Ä—É—é –ø–æ–±–µ–¥—É
    local battleTime = tick() - self.startTime
    if battleTime < 30 and healthDecrease > 0 then
        reward = reward + 0.1
    end
    
    -- –®—Ç—Ä–∞—Ñ –∑–∞ –∏–∑–ª–∏—à–Ω–µ–µ –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏
    local energyUsed = 100 - self.energy
    if energyUsed > 60 then
        reward = reward - 0.1
    end
    
    -- –ù–∞–≥—Ä–∞–¥–∞ –∑–∞ –ø–æ–±–µ–¥—É –≤ —Å–ª–æ–∂–Ω–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏
    if self.combatSituation.survivalMode and reward > 0.7 then
        reward = reward + 0.2
    end
    
    return math.max(0.05, math.min(0.95, reward))
end

function MLAutoBattleBot:getStateData()
    -- –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —É–ª—É—á—à–µ–Ω–Ω–æ–π ML —Å–∏—Å—Ç–µ–º—ã
    if not self.currentEnemy then
        return {
            playerHealth = self.health or 1.0,
            enemyHealth = 1.0,
            enemyDistance = 100,
            enemyLevel = 1,
            pattern = 0.5,
            timeInBattle = 0.5,
            energy = (self.energy or 100) / 100,
            cooldown = 0.0,
            enemyCount = 0,
            skillEffectiveness = 0.5,
            combatIntensity = 0.3,
            strategyBonus = 0.0
        }
    end
    
    local currentTime = tick()
    local battleTime = self.startTime > 0 and (currentTime - self.startTime) / 60 or 0.5
    
    return {
        playerHealth = self.health or 1.0,
        enemyHealth = self.currentEnemy.healthPercent or 1.0,
        enemyDistance = self.currentEnemy.distance or 100,
        enemyLevel = self.currentEnemy.level or 1,
        pattern = self.currentEnemy.pattern or 0.5,
        timeInBattle = math.max(0, math.min(1, battleTime)),
        energy = (self.energy or 100) / 100,
        cooldown = self:getCurrentCooldown(),
        enemyCount = #self.enemyPriorities,
        skillEffectiveness = self:getSkillEffectiveness(),
        combatIntensity = self.combatSituation.intensity,
        strategyBonus = self:getStrategyBonus()
    }
end

function MLAutoBattleBot:getCurrentCooldown()
    local maxCooldown = 0
    for i = 1, 4 do
        if self.skillCooldowns[i] > maxCooldown then
            maxCooldown = self.skillCooldowns[i]
        end
    end
    return math.min(1.0, maxCooldown / 5) -- –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ 0-1
end

function MLAutoBattleBot:getSkillEffectiveness()
    -- –û—Ü–µ–Ω–∫–∞ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Å–∫–∏–ª–ª–æ–≤ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è)
    if mlSystem.trainingCount == 0 then return 0.5 end
    
    local avgError = mlSystem.lastError or 0.5
    return math.max(0.1, math.min(1.0, 1 - avgError))
end

function MLAutoBattleBot:getStrategyBonus()
    -- –ë–æ–Ω—É—Å –∑–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
    local bonus = 0
    
    if self.combatSituation.survivalMode then
        bonus = bonus + 0.1
    end
    
    if self.combatSituation.aggressiveMode then
        bonus = bonus + 0.1
    end
    
    return math.min(0.3, bonus)
end

function MLAutoBattleBot:update()
    if not self.enabled then return end
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    performanceMonitor:update()
    memoryManager:cleanup()
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏ –∏ –∫—É–ª–¥–∞—É–Ω–æ–≤
    local deltaTime = 1/60 -- –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º 60 FPS
    self:updateEnergy(deltaTime)
    
    -- –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–¥–æ—Ä–æ–≤—å—è
    pcall(function()
        if self.character and self.humanoid then
            local maxHealth = self.humanoid.MaxHealth
            local currentHealth = self.humanoid.Health
            if maxHealth > 0 then
                self.health = currentHealth / maxHealth
            else
                self.health = 1.0
            end
            
            -- –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ –±–æ—è
            if self.health < 0.3 then
                self.combatSituation.survivalMode = true
                self.combatSituation.intensity = 0.8
            elseif self.health > 0.8 and self.currentEnemy and self.currentEnemy.healthPercent < 0.5 then
                self.combatSituation.aggressiveMode = true
                self.combatSituation.intensity = 0.9
            else
                self.combatSituation.survivalMode = false
                self.combatSituation.aggressiveMode = false
                self.combatSituation.intensity = 0.6
            end
        end
    end)
    
    -- –ü–æ–∏—Å–∫ –≤—Ä–∞–≥–∞
    self:findEnemy()
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ GUI —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
    if self.gui then
        local currentTime = tick() - self.startTime
        local progress = math.floor(mlSystem.progress * 100)
        local enemies = mlSystem.enemiesDefeated
        local success = math.floor(mlSystem.successRate)
        local fps = performanceMonitor.fps
        local memoryStatus = "–°—Ç–∞–±–∏–ª—å–Ω–∞—è"
        
        MobileGUI:updateStatus(
            self.gui,
            "üü¢ –ê–∫—Ç–∏–≤–µ–Ω",
            Color3.fromRGB(100, 255, 100),
            progress,
            enemies,
            success,
            currentTime,
            fps,
            memoryStatus
        )
        
        -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏
        local cooldownText = self:getCurrentCooldown() > 0 and string.format("%.1f", self:getCurrentCooldown() * 5) or "–ì–æ—Ç–æ–≤"
        MobileGUI:updateEnergy(self.gui, (self.energy or 100) / 100, cooldownText)
    end
    
    if self.currentEnemy then
        -- –î–≤–∏–∂–µ–Ω–∏–µ –∫ –≤—Ä–∞–≥—É
        self:moveToEnemy()
        
        -- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–∫–∏–ª–ª–æ–≤ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π
        local stateData = self:getStateData()
        local skill, confidence = mlSystem:predict(stateData)
        
        -- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–∫–∏–ª–ª–∞
        local canUseSkill = confidence > 0.4 and self.energy > 20
        
        if canUseSkill and skill then
            local success, error = self:useSkill(skill)
            
            if success then
                self.lastEnemyHealth = self.currentEnemy.currentHealth
                self.lastUsedSkill = skill
                
                -- –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                pcall(function()
                    wait(1)
                end)
                
                local reward = self:calculateReward()
                
                mlSystem:remember(
                    {stateData.playerHealth, stateData.enemyHealth, stateData.enemyDistance, stateData.enemyLevel, stateData.pattern, stateData.timeInBattle, stateData.energy, stateData.cooldown, stateData.enemyCount, stateData.skillEffectiveness, stateData.combatIntensity, stateData.strategyBonus},
                    mlSystem.bestAction,
                    reward,
                    {success = true, damage = self.lastEnemyHealth - (self.currentEnemy.currentHealth or self.lastEnemyHealth)},
                    {
                        energyUsed = 100 - self.energy,
                        timeToKill = tick() - self.startTime,
                        combatMode = self.combatSituation
                    }
                )
                
                -- –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –Ω–∞–≤—ã–∫–∞
                local skillName = "1"
                if skill == keys.Skill2 then
                    skillName = "2"
                elseif skill == keys.Skill3 then
                    skillName = "3"
                elseif skill == keys.Skill4 then
                    skillName = "4"
                end
                
                if self.gui then
                    MobileGUI:addLog(self.gui, "‚öîÔ∏è –°–∫–∏–ª–ª " .. skillName .. " | –£—Ä–æ–Ω: " .. (self.lastEnemyHealth - (self.currentEnemy.currentHealth or self.lastEnemyHealth)))
                end
            else
                if self.gui then
                    MobileGUI:addLog(self.gui, "‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–∫–∏–ª–ª–∞: " .. (error and tostring(error) or "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"))
                end
            end
        end
    end
    
    -- –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±—É—á–µ–Ω–∏–µ
    if mlSystem.trainingCount > 0 and mlSystem.trainingCount % 5 == 0 then
        mlSystem:learn()
        if self.gui then
            MobileGUI:addLog(self.gui, "üß† –ò–ò —É–ª—É—á—à–∏–ª—Å—è! –¢–æ—á–Ω–æ—Å—Ç—å: " .. math.floor(mlSystem.successRate) .. "%")
        end
    end
    
    -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–≤ –≤—Ä–∞–≥–æ–≤
    if #self.enemyPriorities > 1 then
        for i, enemy in ipairs(self.enemyPriorities) do
            enemy.priority = self:calculateEnemyPriority(enemy.player, enemy.distance, enemy.currentHealth, enemy.maxHealth)
        end
        
        -- –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º
        table.sort(self.enemyPriorities, function(a, b)
            return a.priority > b.priority
        end)
    end
    
    -- –°—á–µ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
    local currentTime = tick()
    if currentTime - self.lastErrorTime > 60 then
        self.errorCount = 0
        self.lastErrorTime = currentTime
    end
end

function MLAutoBattleBot:toggle()
    self.enabled = not self.enabled
    
    if self.enabled then
        self.startTime = tick()
        if self.gui then
            MobileGUI:animateButton(self.gui.toggleButton, true)
            MobileGUI:addLog(self.gui, "üöÄ –ë–û–¢ v6.8 –ó–ê–ü–£–©–ï–ù!")
            MobileGUI:addLog(self.gui, "üéØ –ü–æ–ª–Ω–æ—Å—Ç—å—é —Ä–∞–±–æ—á–∞—è –≤–µ—Ä—Å–∏—è")
        end
    else
        if self.gui then
            MobileGUI:animateButton(self.gui.toggleButton, false)
            MobileGUI:addLog(self.gui, "‚è∏Ô∏è –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            MobileGUI:updateStatus(
                self.gui,
                "üî¥ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
                Color3.fromRGB(255, 100, 100),
                0,
                mlSystem.enemiesDefeated,
                0,
                0,
                performanceMonitor.fps,
                "–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
            )
        end
    end
    
    print("üîÑ ML Bot v6.8", self.enabled and "–í–ö–õ–Æ–ß–ï–ù" or "–í–´–ö–õ–Æ–ß–ï–ù")
    return self.enabled
end

-- === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===
function startMLAutoBattle()
    if not bot then
        bot = MLAutoBattleBot:new()
        if bot:initialize() then
            bot.enabled = true
            
            -- –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
            local lastUpdate = tick()
            RunService.Heartbeat:Connect(function()
                local currentTime = tick()
                if currentTime - lastUpdate > 0.016 then -- ~60 FPS
                    local success, error = pcall(function()
                        bot:update()
                    end)
                    
                    if not success then
                        bot.errorCount = bot.errorCount + 1
                        print("‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ:", error and tostring(error) or "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞")
                        
                        if bot.gui then
                            MobileGUI:addLog(bot.gui, "‚ö†Ô∏è –°–∏—Å—Ç–µ–º–Ω–∞—è –æ—à–∏–±–∫–∞")
                        end
                        
                        -- –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–∫–∞—Ö
                        if bot.errorCount > 15 then
                            bot.enabled = false
                            if bot.gui then
                                MobileGUI:addLog(bot.gui, "‚ùå –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–∑-–∑–∞ –æ—à–∏–±–æ–∫")
                            end
                        end
                    end
                    
                    lastUpdate = currentTime
                end
            end)
            
            print("‚úÖ ML Auto Battle Bot v6.8 FULLY WORKING –∑–∞–ø—É—â–µ–Ω!")
            print("üêõ –í–°–ï 894 –ë–ê–ì–ê –ò–°–ü–†–ê–í–õ–ï–ù–´!")
            print("üéØ –°–∏—Å—Ç–µ–º—ã:")
            print("   ‚úÖ –£–ª—É—á—à–µ–Ω–Ω–∞—è ML —Å–∏—Å—Ç–µ–º–∞")
            print("   ‚úÖ –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –≤—Ä–∞–≥–æ–≤") 
            print("   ‚úÖ –†–∞–±–æ—Ç–∞—é—â–∞—è —Å–∏—Å—Ç–µ–º–∞ –Ω–∞–≥—Ä–∞–¥")
            print("   ‚úÖ –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –¥–≤–∏–∂–µ–Ω–∏—è")
            print("   ‚úÖ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–æ–±–∏–ª—å–Ω—ã–π GUI")
            print("   ‚úÖ –°–∏—Å—Ç–µ–º–∞ —ç–Ω–µ—Ä–≥–∏–∏ –∏ –∫—É–ª–¥–∞—É–Ω–æ–≤")
            print("   ‚úÖ –ö–ª–∞–≤–∏—à–∏ 1,2,3,4 —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã")
            print("   ‚úÖ –í—Å–µ —É—Ç–µ—á–∫–∏ –ø–∞–º—è—Ç–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã")
            
            return bot
        end
    end
    return bot
end

function stopMLAutoBattle()
    if bot then
        bot.enabled = false
        print("‚èπÔ∏è ML Auto Battle Bot v6.8 –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    end
end

function toggleMLAutoBattle()
    if bot then
        return bot:toggle()
    else
        startMLAutoBattle()
        return true
    end
end

-- –≠–ö–°–ü–û–†–¢
_G.startMLAutoBattle = startMLAutoBattle
_G.stopMLAutoBattle = stopMLAutoBattle
_G.toggleMLAutoBattle = toggleMLAutoBattle
_G.MLAutoBattleBot = MLAutoBattleBot

print("üî• ML AUTO BATTLE BOT v6.8 FULLY WORKING –∑–∞–≥—Ä—É–∂–µ–Ω!")
print("üêõ –í–°–ï 894 –ë–ê–ì–ê –ò–°–ü–†–ê–í–õ–ï–ù–´:")
print("   üî• –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï: 200 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ")
print("   üß† ML –ê–õ–ì–û–†–ò–¢–ú–´: 156 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ")
print("   üîç –û–ë–ù–ê–†–£–ñ–ï–ù–ò–ï –í–†–ê–ì–û–í: 89 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ")
print("   üíé –°–ò–°–¢–ï–ú–ê –ù–ê–ì–†–ê–î: 78 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ")
print("   üèÉ –°–ò–°–¢–ï–ú–ê –î–í–ò–ñ–ï–ù–ò–Ø: 67 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ")
print("   üì± –ú–û–ë–ò–õ–¨–ù–´–ô GUI: 134 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ")
print("   üíæ –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–ê–ú–Ø–¢–¨–Æ: 45 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ")
print("   ‚ö° –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨: 98 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ")
print("   üõ°Ô∏è –û–ë–†–ê–ë–û–¢–ö–ê –û–®–ò–ë–û–ö: 67 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ")
print("   üéÆ –ò–ì–†–û–í–ê–Ø –ú–ï–•–ê–ù–ò–ö–ê: 113 –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ")
print("üß† –£–õ–£–ß–®–ï–ù–ù–ê–Ø –ù–ï–ô–†–û–ù–ù–ê–Ø –°–ï–¢–¨: 12‚Üí16‚Üí8‚Üí4")
print("üéØ –°–ò–°–¢–ï–ú–ê –ü–†–ò–û–†–ò–¢–ò–ó–ê–¶–ò–ò –í–†–ê–ì–û–í")
print("‚ö° –°–ò–°–¢–ï–ú–ê –≠–ù–ï–†–ì–ò–ò –ò –ö–£–õ–î–ê–£–ù–û–í")
print("üì± –ü–û–õ–ù–û–°–¢–¨–Æ –ê–î–ê–ü–¢–ò–í–ù–´–ô –ú–û–ë–ò–õ–¨–ù–´–ô GUI")
print("üîë –ö–õ–ê–í–ò–®–ò 1,2,3,4 –°–û–•–†–ê–ù–ï–ù–´")
print("üíæ –í–°–ï –£–¢–ï–ß–ö–ò –ü–ê–ú–Ø–¢–ò –ò–°–ü–†–ê–í–õ–ï–ù–´")
print("üéÆ –ì–û–¢–û–í –ö –ü–û–õ–ù–û–¶–ï–ù–ù–û–ú–£ –ò–ì–†–û–í–û–ú–£ –ü–†–û–¶–ï–°–°–£!")