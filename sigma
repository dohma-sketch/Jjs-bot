-- jjs_agent_v4_final.lua
-- v4 final: hybrid learning agent for Jujutsu Shenanigans
-- Hardened: safe IO, protected calls, improved movement (no PathfindingService),
-- improved raycast-based steering, anti-stuck, replay, bandit, Q/SARSA, diagnostics.

-- ===== Services & locals =====
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local Debris = game:GetService("Debris")

local okVIM, VIM = pcall(function() return game:GetService("VirtualInputManager") end)
if not okVIM then VIM = nil end

local LocalPlayer = Players.LocalPlayer

local function getCharacter()
    if not LocalPlayer then return nil end
    return LocalPlayer.Character or (LocalPlayer.CharacterAdded and LocalPlayer.CharacterAdded:Wait())
end

local char = getCharacter()
local humanoid, hrp
local camera = workspace.CurrentCamera

local function bindCharacterParts()
    char = getCharacter()
    if not char then return end
    humanoid = char:FindFirstChildOfClass("Humanoid") or char:FindFirstChild("Humanoid")
    hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or hrp
    camera = workspace.CurrentCamera or camera
end
pcall(bindCharacterParts)

if LocalPlayer and LocalPlayer.CharacterAdded then
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(0.08)
        pcall(bindCharacterParts)
    end)
end

-- ===== Config =====
local CFG = {
    alpha = 0.55,
    gamma = 0.9,
    epsilon = 0.95,
    epsilonMin = 0.02,
    epsilonDecay = 0.994,
    moveStep = 5,
    attackRange = 12,
    damageWindow = 0.9,
    collisionRayDist = 3,
    replayCapacity = 3000,
    replayBatch = 16,
    saveInterval = 25,
    maxConcurrentMonitors = 5,
    minMoveDelta = 0.5,
    antiStuckAttempts = 3,
    idlePenaltyThreshold = 6,
    prioritizedReplay = true,
    maxStates = 4000,
    maxBanditContexts = 1000,
    qFile = "jjs_qtable.json",
    banditFile = "jjs_bandit.json",
    metaFile = "jjs_meta.json",
    mapUpdateInterval = 0.5,
    sensorDist = 128,
    sensorRays = 16,
    BVName = "_JJS_BV",
    debug = false,
}

-- ===== Safe IO =====
local function hasFileIO()
    return type(isfile) == "function" and type(readfile) == "function" and type(writefile) == "function"
end

local function safeLoadJSON(name)
    if not hasFileIO() then return nil end
    local tries, back = 3, 0.06
    for i = 1, tries do
        local ok, txt = pcall(readfile, name)
        if ok and type(txt) == "string" and #txt > 0 then
            local ok2, obj = pcall(HttpService.JSONDecode, HttpService, txt)
            if ok2 and type(obj) == "table" then return obj end
        end
        task.wait(back); back = back * 1.8
    end
    return nil
end

local function safeSaveJSONAtomic(name, obj)
    if not hasFileIO() then return false end
    local okEnc, enc = pcall(HttpService.JSONEncode, HttpService, obj)
    if not okEnc or type(enc) ~= "string" then return false end
    local tmp = name .. ".tmp"
    local tries, back = 3, 0.06
    for i = 1, tries do
        local okW = pcall(writefile, tmp, enc)
        if okW then
            local okMv = pcall(writefile, name, enc)
            if okMv then return true end
        end
        task.wait(back); back = back * 1.8
    end
    return false
end

-- ===== Load persisted =====
local Q = safeLoadJSON(CFG.qFile) or {}
local bandit = safeLoadJSON(CFG.banditFile) or {}
local meta = safeLoadJSON(CFG.metaFile) or {version=4, created=os.time(), lastSave=os.time()}

-- ===== Replay Memory (simple prioritized) =====
local Replay = {}
Replay.__index = Replay
function Replay.new(capacity)
    return setmetatable({mem = {}, cap = capacity or 1000, sz = 0, idx = 1}, Replay)
end
function Replay:add(s,a,r,ns,done)
    if not s or not a then return end
    local priority = math.min(100, math.abs((r or 0)) + 0.0001)
    self.mem[self.idx] = {s = s, a = a, r = r or 0, ns = ns or s, done = done or false, p = priority}
    self.idx = (self.idx % self.cap) + 1
    if self.sz < self.cap then self.sz = self.sz + 1 end
end
function Replay:sample(n)
    if self.sz == 0 then return {} end
    n = math.min(n, self.sz)
    if CFG.prioritizedReplay then
        local total = 0
        for i=1,self.sz do total = total + (self.mem[i].p or 0) end
        if total <= 0 then
            local res = {}
            for i=1,n do res[#res+1] = self.mem[math.random(1,self.sz)] end
            return res
        end
        local out = {}
        for k=1,n do
            local pick = math.random() * total
            local acc = 0
            for i=1,self.sz do
                acc = acc + (self.mem[i].p or 0)
                if acc >= pick then out[#out+1] = self.mem[i]; break end
            end
        end
        return out
    else
        local res={}
        for i=1,n do res[#res+1] = self.mem[math.random(1,self.sz)] end
        return res
    end
end
local replay = Replay.new(CFG.replayCapacity)

-- ===== Utils =====
local function now() return tick() end
local function clamp(v, lo, hi) if v < lo then return lo end if v > hi then return hi end return v end
local function safePcall(f, ...) if type(f)~="function" then return false end; local ok,res = pcall(f, ...); return ok and res or nil end
local function safeMag(a,b)
    if not a or not b then return math.huge end
    local ok, v = pcall(function() return (a - b).Magnitude end)
    if ok and v then return v end
    return math.huge
end

-- ===== Sensors & map memory =====
local mapMemory = {} -- posKey -> {kind="free"/"blocked", t=..., c=confidence}
local function posKey(vec)
    if not vec then return "nil" end
    local x = math.floor(vec.X + 0.5)
    local y = math.floor(vec.Y + 0.5)
    local z = math.floor(vec.Z + 0.5)
    return x.."|"..y.."|"..z
end

local function raycastFrom(origin, dir, length, filterList)
    if not origin or not dir then return nil end
    local rp = RaycastParams.new()
    rp.FilterDescendantsInstances = filterList or {char}
    rp.FilterType = Enum.RaycastFilterType.Blacklist
    rp.IgnoreWater = true
    local ok, res = pcall(function() return workspace:Raycast(origin + Vector3.new(0,1.5,0), dir.Unit * (length or CFG.sensorDist), rp) end)
    if ok then return res else return nil end
end

local function scanRing(origin, rays)
    rays = math.max(1, rays or CFG.sensorRays)
    origin = origin or (hrp and hrp.Position) or Vector3.new(0,0,0)
    local out = {}
    for i=0, rays-1 do
        local ang = (i / math.max(1, rays)) * math.pi * 2
        local dir = Vector3.new(math.cos(ang), 0, math.sin(ang))
        local res = raycastFrom(origin, dir, CFG.sensorDist)
        out[#out+1] = {dir=dir, hit=(res~=nil), dist=(res and safeMag(res.Position, origin)) or CFG.sensorDist, inst=(res and res.Instance) or nil}
    end
    return out
end

local function updateMapOnce()
    if not hrp then return end
    local origin = hrp.Position
    local scan = scanRing(origin, CFG.sensorRays)
    for i=1,#scan do
        local s = scan[i]
        local dist = s.dist or CFG.sensorDist
        local samplePos = origin + s.dir * math.min(dist * 0.5, CFG.sensorDist)
        local key = posKey(samplePos)
        if key and key ~= "nil" then
            local nowt = tick()
            local prev = mapMemory[key]
            if s.hit then
                mapMemory[key] = {kind="blocked", t = nowt, c = (prev and math.min(1, (prev.c or 0) + 0.4)) or 0.6}
            else
                mapMemory[key] = {kind="free", t = nowt, c = (prev and math.min(1, (prev.c or 0) + 0.3)) or 0.5}
            end
        end
    end
end

-- periodic map updater
task.spawn(function()
    while true do
        task.wait(CFG.mapUpdateInterval or 0.5)
        pcall(updateMapOnce)
    end
end)

-- ===== Movement helpers (raycast steering and BV fallback) =====
local function rotateYUnit(vec, deg)
    if not vec or vec.Magnitude < 1e-6 then return nil end
    local cf = CFrame.Angles(0, math.rad(deg), 0)
    local r = cf:VectorToWorldSpace(vec)
    if not r or r.Magnitude < 1e-6 then return nil end
    return Vector3.new(r.X,0,r.Z).Unit
end

local function isPathClearSimple(fromPos, dirUnit, length)
    if not fromPos or not dirUnit or dirUnit.Magnitude < 1e-6 then return false end
    length = length or math.min(CFG.sensorDist, 16)
    local res = raycastFrom(fromPos, dirUnit, length)
    return res == nil
end

local function steerTo(desiredUnit)
    if not hrp or not desiredUnit or desiredUnit.Magnitude < 1e-6 then return nil end
    if isPathClearSimple(hrp.Position, desiredUnit, math.min(16, CFG.sensorDist)) then return desiredUnit end
    local angles = {20, -20, 45, -45, 90, -90}
    for _,a in ipairs(angles) do
        local r = rotateYUnit(desiredUnit, a)
        if r and isPathClearSimple(hrp.Position, r, 10) then return r end
    end
    local s = scanRing(hrp.Position, math.min(12, CFG.sensorRays))
    for i=1,#s do if not s[i].hit then return s[i].dir end end
    return nil
end

local function ensureBV()
    if not hrp then return nil end
    local existing = hrp:FindFirstChild(CFG.BVName)
    if existing and existing:IsA("BodyVelocity") then return existing end
    local ok, obj = pcall(function()
        local b = Instance.new("BodyVelocity")
        b.Name = CFG.BVName
        b.MaxForce = Vector3.new(1e5,0,1e5)
        b.P = 3000
        b.Parent = hrp
        return b
    end)
    return ok and obj or nil
end

local function setVelocity(vec)
    if not hrp then return end
    local bv = ensureBV()
    if not bv then
        -- fallback to MoveTo if BV not allowed
        local dest = hrp.Position + Vector3.new(vec.X,0,vec.Z)
        pcall(function() humanoid:MoveTo(dest) end)
        return
    end
    local cur = bv.Velocity or Vector3.new(0,0,0)
    local s = 0.6
    local v = Vector3.new(cur.X * (1-s) + vec.X * s, 0, cur.Z * (1-s) + vec.Z * s)
    bv.Velocity = v
end

local function clearBV()
    if not hrp then return end
    local b = hrp:FindFirstChild(CFG.BVName)
    if b and b.Parent then pcall(function() b:Destroy() end) end
end

-- Anti-stuck helpers
local lastPositions = {}
local function recordPosition()
    if not hrp then return end
    table.insert(lastPositions, 1, hrp.Position)
    if #lastPositions > 20 then table.remove(lastPositions) end
end
local function isStuck()
    if #lastPositions < 6 then return false end
    local sum = 0
    for i=1,5 do
        local a = lastPositions[i]; local b = lastPositions[i+1]
        if a and b then sum = sum + (a - b).Magnitude end
    end
    return sum < 0.6
end

-- ===== Input helpers =====
local function doClick()
    if not VIM or not camera then return false end
    local ok, size = pcall(function() return camera.ViewportSize end)
    if not ok or not size then return false end
    local x,y = size.X/2, size.Y/2
    pcall(function()
        if VIM and type(VIM.SendMouseButtonEvent) == "function" then
            VIM:SendMouseButtonEvent(x,y,0,true,game,0)
            task.wait(0.04)
            VIM:SendMouseButtonEvent(x,y,0,false,game,0)
        end
    end)
    return true
end
local function doHeavyClick()
    if not VIM or not camera then return false end
    local ok, size = pcall(function() return camera.ViewportSize end)
    if not ok or not size then return false end
    local x,y = size.X/2, size.Y/2
    pcall(function()
        if VIM and type(VIM.SendMouseButtonEvent) == "function" then
            VIM:SendMouseButtonEvent(x,y,0,true,game,0)
            task.wait(0.12)
            VIM:SendMouseButtonEvent(x,y,0,false,game,0)
        end
    end)
    return true
end
local skillKeys = {Enum.KeyCode.One,Enum.KeyCode.Two,Enum.KeyCode.Three,Enum.KeyCode.Four}
local function pressSkill(idx)
    local key = skillKeys[idx]
    if not VIM or not key then return false end
    pcall(function()
        if VIM and type(VIM.SendKeyEvent) == "function" then
            VIM:SendKeyEvent(true,key,false,game)
            task.wait(0.06)
            VIM:SendKeyEvent(false,key,false,game)
        end
    end)
    return true
end

-- ===== Targeting & state =====
local function findNearestTarget()
    if not hrp then pcall(bindCharacterParts) end
    local nearest, nd = nil, math.huge
    for _,pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character.Parent then
            local ch = pl.Character
            local hrp2 = ch:FindFirstChild("HumanoidRootPart")
            local hum2 = ch:FindFirstChildOfClass("Humanoid")
            if hrp2 and hum2 and hum2.Health and hum2.Health > 0 then
                local ok, d = pcall(function() return (hrp.Position - hrp2.Position).Magnitude end)
                if ok and d and d < nd then nd, nearest = d, ch end
            end
        end
    end
    return nearest, nd
end

local function compressRecent(lastActions)
    if not lastActions or #lastActions == 0 then return "m_none" end
    local start = math.max(1,#lastActions-2)
    local out = "m"
    for i=start,#lastActions do out = out.."_"..tostring(lastActions[i]) end
    return out
end

local function getState(target, lastActions)
    if not target or not target.Parent or not target:FindFirstChild("HumanoidRootPart") or not target:FindFirstChildOfClass("Humanoid") then
        return "no_target"
    end
    local ok, dist = pcall(function() return (hrp.Position - target.HumanoidRootPart.Position).Magnitude end)
    if not ok or not dist then dist = 9999 end
    local range = (dist < 6 and "close") or (dist < 15 and "mid") or "far"

    local rayP = RaycastParams.new()
    rayP.FilterDescendantsInstances = {char}
    rayP.FilterType = Enum.RaycastFilterType.Blacklist
    rayP.IgnoreWater = true
    local vis = "novis"
    if target:FindFirstChild("Head") then
        local ok2, r = pcall(function() return workspace:Raycast(hrp.Position, (target.Head.Position - hrp.Position), rayP) end)
        if ok2 and (r == nil or (r.Instance and r.Instance:IsDescendantOf(target))) then vis = "vis" end
    end

    local okhp, th = pcall(function()
        local H = target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health
        local M = math.max((target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").MaxHealth) or 1,1)
        return (H and (H / M)) or 1
    end)
    if not okhp then th = 1 end
    local hpb = (th > 0.7 and "hp_high") or (th > 0.3 and "hp_med") or "hp_low"

    local mem = compressRecent(lastActions)
    local state = range.."|"..vis.."|"..hpb.."|"..mem
    if #state > 200 then state = state:sub(1,200) end
    return state
end

-- ===== Q-table & combo data =====
local actions = {
    "move_forward","move_backward","move_left","move_right",
    "jump","idle",
    "click_attack","skill_1","skill_2","skill_3","skill_4"
}

local function initState(s)
    if not s then return end
    if not Q[s] then
        -- prune if Q too large
        local count = 0 for _ in pairs(Q) do count = count + 1 end
        if count > CFG.maxStates then
            local toRemove = {}
            for k,v in pairs(Q) do
                local sum = 0
                for i=1,#v do sum = sum + math.abs(v[i] or 0) end
                if sum < 0.001 then toRemove[#toRemove+1] = k end
            end
            for _,k in ipairs(toRemove) do Q[k] = nil end
        end
        Q[s] = {}
        for i = 1, #actions do Q[s][i] = 0 end
    end
end

local function chooseAction(s)
    initState(s)
    if math.random() < CFG.epsilon then
        return math.random(1,#actions)
    else
        local bestVal, bestIdx = -math.huge, 1
        for i,v in ipairs(Q[s] or {}) do if v and v > bestVal then bestVal, bestIdx = v, i end end
        return bestIdx
    end
end

-- ===== Bandit (attacks) =====
local baseAttacks = {"click","heavy","skill1","skill2","skill3","skill4"}
local function ensureContext(ctx)
    if not ctx then return end
    if not bandit[ctx] then bandit[ctx] = {meta = {created = now(), last = now()}} end
    for _,nm in ipairs(baseAttacks) do
        if not bandit[ctx][nm] then bandit[ctx][nm] = {wins=0,plays=0} end
    end
    bandit[ctx].meta.last = now()
end

local function chooseAttackForContext(ctx)
    if not ctx then return "click" end
    ensureContext(ctx)
    local total = 0
    for _,v in pairs(bandit[ctx]) do if type(v)=="table" and v.plays then total = total + (v.plays) end end
    total = math.max(total,1)
    local best, bestVal = nil, -math.huge
    for name,st in pairs(bandit[ctx]) do
        if type(st)=="table" and st.plays ~= nil then
            local plays = st.plays or 0
            local wins = st.wins or 0
            local avg = (plays>0) and (wins/plays) or 0.4
            local bonus = (plays>0) and math.sqrt(2*math.log(total)/math.max(1,plays)) or 1.0
            local val = avg + bonus
            if val > bestVal then bestVal, best = val, name end
        end
    end
    return best or "click"
end

local function registerAttack(ctx,name,success)
    if not ctx or not name then return end
    ensureContext(ctx)
    local s = bandit[ctx][name]
    s.plays = (s.plays or 0) + 1
    if success then s.wins = (s.wins or 0) + 1 end
end

local function pruneBandit()
    local keys = {}
    for k,v in pairs(bandit) do
        if type(v) == "table" and v.meta then
            local total = 0
            for an,av in pairs(v) do if type(av)=="table" and av.plays then total = total + (av.plays or 0) end end
            table.insert(keys, {k=k,score=total,last=v.meta.last})
        end
    end
    table.sort(keys, function(a,b) return a.score > b.score end)
    for i = CFG.maxBanditContexts+1, #keys do
        bandit[keys[i].k] = nil
    end
end

-- ===== Health monitor (safe) =====
local lastMyHealth = (humanoid and humanoid.Health) or 100
local function monitorSelfDamage()
    if not humanoid then return false end
    local cur = humanoid.Health or lastMyHealth
    local changed = cur < lastMyHealth
    lastMyHealth = cur
    return changed
end

local activeMonitors = 0
local function monitorTargetDamage(target, startHP, window, callback)
    if not target or type(callback) ~= "function" then if callback then pcall(callback,false) end; return end
    if activeMonitors >= CFG.maxConcurrentMonitors then
        task.spawn(function()
            task.wait(math.min(0.18, window or 0.2))
            local ok, cur = pcall(function() return target and target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health end)
            if ok and cur and startHP and cur < startHP then pcall(callback,true) else pcall(callback,false) end
        end)
        return
    end
    activeMonitors = activeMonitors + 1
    task.spawn(function()
        local t0 = now(); local success=false
        while now() - t0 < (window or CFG.damageWindow) do
            if not target or not target.Parent or not target:FindFirstChildOfClass("Humanoid") then break end
            local ok, cur = pcall(function() return target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health end)
            if ok and cur and startHP and cur < startHP then success = true; break end
            task.wait(0.04)
        end
        pcall(callback, success)
        activeMonitors = math.max(0, activeMonitors - 1)
    end)
end

-- ===== Reward logic =====
local lastActionIdx = nil
local lastSkillUsed = nil
local idleLoops = 0
local function computeReward(actionIdx, target, oldDist, collidedWithWall, gotDamage, didDamage, targetMovedAway)
    local actionName = actions[actionIdx] or "idle"
    local r = 0
    if target then
        local ok, newDist = pcall(function() return (hrp.Position - target.HumanoidRootPart.Position).Magnitude end)
        if ok and newDist then
            if newDist < oldDist then r = r + 0.6 else r = r - 0.35 end
            if targetMovedAway then r = r - 0.9 end
        else r = r - 0.5 end
    else r = r - 0.6 end
    if collidedWithWall then r = r - 2.2 end
    if gotDamage then r = r - 2.5 end
    if didDamage then r = r + 3.2 end
    if actionName:match("skill") then
        if lastSkillUsed == actionName then r = r - 1.2 end
        lastSkillUsed = actionName
    else lastSkillUsed = nil end
    if lastActionIdx == actionIdx then r = r - 0.06 end
    lastActionIdx = actionIdx
    if actionName == "idle" then idleLoops = idleLoops + 1; if idleLoops > CFG.idlePenaltyThreshold then r = r - 0.2 end
    else idleLoops = 0 end
    return r
end

-- ===== Q/SARSA update & replay training =====
local function safeMax(tbl)
    if not tbl or type(tbl) ~= "table" then return 0 end
    local m = -math.huge
    for i,v in ipairs(tbl) do if v and v > m then m = v end end
    if m == -math.huge then return 0 end
    return m
end

local function updateQ(state, aIdx, reward, nextState, nextAIdx, method)
    if not state or not aIdx then return end
    initState(state); initState(nextState)
    if method == "Q" then
        local maxNext = safeMax(Q[nextState])
        Q[state][aIdx] = (Q[state][aIdx] or 0) + CFG.alpha * (reward + CFG.gamma * maxNext - (Q[state][aIdx] or 0))
    else
        local nextVal = (Q[nextState] and Q[nextState][nextAIdx]) or 0
        Q[state][aIdx] = (Q[state][aIdx] or 0) + CFG.alpha * (reward + CFG.gamma * nextVal - (Q[state][aIdx] or 0))
    end
end

local function replayTrain()
    if replay.sz < 1 then return end
    local batch = replay:sample(CFG.replayBatch or 16)
    for _,t in ipairs(batch) do
        local s,a,r,ns,done = t.s, t.a, t.r, t.ns, t.done
        if s and a then
            local nextA = chooseAction(ns)
            updateQ(s,a,r,ns,nextA,"Q")
        end
    end
end

-- ===== Prune & garbage =====
local function pruneQ()
    local count = 0 for _ in pairs(Q) do count = count + 1 end
    if count <= CFG.maxStates then return end
    local scores = {}
    for k,v in pairs(Q) do
        local s = 0
        for i=1,#v do s = s + math.abs(v[i] or 0) end
        table.insert(scores, {k=k,score=s})
    end
    table.sort(scores, function(a,b) return a.score < b.score end)
    for i=1, math.min(#scores, count - CFG.maxStates) do Q[scores[i].k] = nil end
    pcall(function() collectgarbage("collect") end)
end

local function pruneBanditAndGarbage()
    pruneBandit()
    local torem = {}
    for k,v in pairs(bandit) do
        if type(v)=="table" and v.meta and v.meta.last then
            local total = 0
            for an,av in pairs(v) do if type(av)=="table" and av.plays then total = total + (av.plays or 0) end end
            if total < 2 and (now() - v.meta.last) > 3600 then torem[#torem+1] = k end
        end
    end
    for _,k in ipairs(torem) do bandit[k] = nil end
    pcall(function() collectgarbage("collect") end)
end

-- ===== Diagnostics & _G API =====
local metrics = {loops=0,collisions=0,hits=0,damageTaken=0,avgReward=0,samples=0}
_G.JJS_AGENT = _G.JJS_AGENT or {}
_G.JJS_AGENT.reset = function()
    Q = {}; bandit = {}; replay = Replay.new(CFG.replayCapacity)
    safeSaveJSONAtomic(CFG.qFile,Q); safeSaveJSONAtomic(CFG.banditFile,bandit)
    print("[JJS_AGENT] reset done")
end
_G.JJS_AGENT.dump = function()
    safeSaveJSONAtomic("jjs_q_dump.json",Q); safeSaveJSONAtomic("jjs_bandit_dump.json",bandit)
    print("[JJS_AGENT] dump saved")
end
_G.JJS_AGENT.prune = function()
    pruneQ(); pruneBanditAndGarbage()
    print("[JJS_AGENT] prune done")
end
_G.JJS_AGENT.status = function()
    local qcount = 0 for _ in pairs(Q) do qcount = qcount + 1 end
    local bcount = 0 for _ in pairs(bandit) do bcount = bcount + 1 end
    print(("status: qstates=%d bandit_ctx=%d replay=%d eps=%.4f"):format(qcount,bcount,replay.sz,CFG.epsilon))
end

local function logMetrics()
    local avg = metrics.samples > 0 and (metrics.avgReward / metrics.samples) or 0
    print(("[JJS AGENT] loops=%d collisions=%d hits=%d dmgTaken=%d avgR=%.3f eps=%.3f"):format(
        metrics.loops, metrics.collisions, metrics.hits, metrics.damageTaken, avg, CFG.epsilon))
end

-- ===== Main loop =====
local lastSave = now()
local loopTick = 0
local recentActions = {}
local function pushRecent(a) recentActions[#recentActions+1] = a; if #recentActions > 6 then table.remove(recentActions,1) end end

task.spawn(function()
    while true do
        loopTick = loopTick + 1
        metrics.loops = metrics.loops + 1
        recordPosition()

        if not (char and char.Parent and humanoid and hrp) then
            pcall(bindCharacterParts)
            task.wait(0.12)
            goto CONT
        end

        local target, oldDist = findNearestTarget()
        oldDist = oldDist or math.huge

        local state = getState(target, recentActions)
        initState(state)
        local actionIdx = chooseAction(state)
        local actionName = actions[actionIdx] or "idle"

        -- visibility ray
        local rayP = RaycastParams.new(); rayP.FilterDescendantsInstances = {char}; rayP.FilterType = Enum.RaycastFilterType.Blacklist; rayP.IgnoreWater = true
        local visible = false
        if target and target:FindFirstChild("Head") then
            local ok,r = pcall(function() return workspace:Raycast(hrp.Position, (target.Head.Position - hrp.Position), rayP) end)
            if ok and (r == nil or (r.Instance and r.Instance:IsDescendantOf(target))) then visible = true end
        end

        -- execute action
        local collided=false; local attackName=nil; local targetStartHP=nil
        if actionName == "move_forward" and target and target:FindFirstChild("HumanoidRootPart") then
            local dir = (target.HumanoidRootPart.Position - hrp.Position)
            if dir and dir.Magnitude > 0.2 then
                local desired = Vector3.new(dir.X,0,dir.Z).Unit
                local steer = steerTo(desired)
                if steer then setVelocity(steer * CFG.moveStep) else collided=true; metrics.collisions=metrics.collisions+1; clearBV() end
            end
        elseif actionName == "move_backward" and target and target:FindFirstChild("HumanoidRootPart") then
            local dir = (hrp.Position - target.HumanoidRootPart.Position)
            if dir and dir.Magnitude > 0.2 then
                local steer = steerTo(Vector3.new(dir.X,0,dir.Z).Unit)
                if steer then setVelocity(steer * CFG.moveStep) else collided=true; metrics.collisions=metrics.collisions+1; clearBV() end
            end
        elseif actionName == "move_left" and target and target:FindFirstChild("HumanoidRootPart") then
            local dir=(target.HumanoidRootPart.Position-hrp.Position); local left=Vector3.new(-dir.Z,0,dir.X)
            if left and left.Magnitude > 0 then local steer = steerTo(left.Unit); if steer then setVelocity(steer * CFG.moveStep) else collided=true; metrics.collisions=metrics.collisions+1; clearBV() end end
        elseif actionName == "move_right" and target and target:FindFirstChild("HumanoidRootPart") then
            local dir=(target.HumanoidRootPart.Position-hrp.Position); local right=Vector3.new(dir.Z,0,-dir.X)
            if right and right.Magnitude > 0 then local steer = steerTo(right.Unit); if steer then setVelocity(steer * CFG.moveStep) else collided=true; metrics.collisions=metrics.collisions+1; clearBV() end end
        elseif actionName == "jump" then pcall(function() humanoid.Jump = true end); task.wait(0.12); pcall(function() humanoid.Jump = false end)
        elseif actionName == "idle" then clearBV(); task.wait(0.06)
        elseif actionName == "click_attack" then
            if target and target:FindFirstChildOfClass("Humanoid") then
                attackName="click"; targetStartHP = target:FindFirstChildOfClass("Humanoid").Health; doClick()
                monitorTargetDamage(target,targetStartHP,CFG.damageWindow,function(success) if success then metrics.hits=metrics.hits+1 end registerAttack(state,attackName,success) end)
            else task.wait(0.05) end
        elseif actionName:match("^skill_") then
            local idx = tonumber(actionName:match("skill_(%d)"))
            if idx and idx>=1 and idx<=#skillKeys then
                attackName="skill"..tostring(idx); if target and target:FindFirstChildOfClass("Humanoid") then targetStartHP=target:FindFirstChildOfClass("Humanoid").Health end
                pressSkill(idx)
                monitorTargetDamage(target,targetStartHP,CFG.damageWindow,function(success) if success then metrics.hits=metrics.hits+1 end registerAttack(state,attackName,success) end)
            end
        end

        task.wait(0.12)

        local gotDamage = monitorSelfDamage()
        if gotDamage then metrics.damageTaken = metrics.damageTaken + 1 end

        local targetMovedAway = false
        if target and target.Parent and target:FindFirstChild("HumanoidRootPart") then
            local ok, newD = pcall(function() return (hrp.Position - target.HumanoidRootPart.Position).Magnitude end)
            if ok and newD and oldDist and newD > oldDist + 0.4 then targetMovedAway = true end
        end

        local didDamageHeuristic = false
        if target and target:FindFirstChildOfClass("Humanoid") and targetStartHP then
            local ok, cur = pcall(function() return target:FindFirstChildOfClass("Humanoid").Health end)
            if ok and cur and cur < targetStartHP then didDamageHeuristic = true end
        end

        local r = computeReward(actionIdx, target, oldDist, collided, gotDamage, didDamageHeuristic, targetMovedAway)
        metrics.avgReward = (metrics.avgReward or 0) + r; metrics.samples = (metrics.samples or 0) + 1

        pushRecent(actionIdx)
        local nextState = getState(target, recentActions)
        initState(nextState)
        local nextAction = chooseAction(nextState)

        local method = "SARSA"
        if actionName == "click_attack" or actionName:match("^skill_") then method = "Q" end

        replay:add(state, actionIdx, r, nextState, false)
        updateQ(state, actionIdx, r, nextState, nextAction, method)

        if loopTick % 6 == 0 then pcall(replayTrain) end
        if loopTick % 300 == 0 then pcall(pruneQ); pcall(pruneBanditAndGarbage) end

        if now() - lastSave > CFG.saveInterval then
            pcall(function()
                safeSaveJSONAtomic(CFG.qFile, Q)
                safeSaveJSONAtomic(CFG.banditFile, bandit)
                meta.lastSave = os.time()
                safeSaveJSONAtomic(CFG.metaFile, meta)
            end)
            lastSave = now()
        end

        if CFG.epsilon and CFG.epsilon > CFG.epsilonMin then CFG.epsilon = clamp(CFG.epsilon * CFG.epsilonDecay, CFG.epsilonMin, 1) end

        if loopTick % 240 == 0 then logMetrics(); pcall(function() collectgarbage("collect") end) end

        if isStuck() then
            for i=1,CFG.antiStuckAttempts do
                local ang = math.random() * math.pi * 2
                local try = Vector3.new(math.cos(ang),0,math.sin(ang))
                local steer = steerTo(try)
                if steer then setVelocity(steer * CFG.moveStep) end
                task.wait(0.08)
            end
        end

        task.wait(0.04)
        ::CONT::
    end
end)

-- ===== End of file =====
print("[JJS_AGENT] v4 final loaded (hardened)")