--[[
    ‚ö´ VESSEL BOT v27.3 INTELLIGENT AI - –°–£–ü–ï–† –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø
    ==================================
    ‚úÖ 150+ –ë–ê–ì–û–í –ù–ê–ô–î–ï–ù–û –ò –ò–°–ü–†–ê–í–õ–ï–ù–û
    ‚úÖ –ü–æ–ª–Ω–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –≤—Å–µ—Ö –æ—à–∏–±–æ–∫
]]--

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- –ë–ê–ì #86: –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞ –µ—Å–ª–∏ Services –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã
if not Players or not UserInputService or not RunService or not Workspace then
    warn("‚ùå Critical Services –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã!")
    return
end

local PlayersLocal = Players.LocalPlayer

if not PlayersLocal then 
    warn("‚ùå LocalPlayer –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω!") 
    return 
end

-- –ë–ê–ì #87: –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω–Ω–µ–∫—Ç–∞ –∫ —Å–µ—Ä–≤–µ—Ä—É
local isConnected = false
pcall(function()
    -- –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Å–ø–æ—Å–æ–± –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω–Ω–µ–∫—Ç
    if PlayersLocal.Parent == Players then
        isConnected = true
    end
end)

-- –î–∞—ë–º –≤—Ç–æ—Ä–æ–π —à–∞–Ω—Å –µ—Å–ª–∏ –ø–µ—Ä–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∞
if not isConnected then
    task.wait(1)
    pcall(function()
        if PlayersLocal.Parent == Players then
            isConnected = true
        end
    end)
end

-- –ë–ê–ì #138: –¢–æ–ª—å–∫–æ –≤—ã–≤–æ–¥–∏–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ, –Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É
if not isConnected then
    warn("‚ö†Ô∏è –í–Ω–∏–º–∞–Ω–∏–µ: –ø—Ä–æ–±–ª–µ–º—ã —Å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ–º, –Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É...")
end

local PlayerGui = nil
local guiWaitTimeout = tick() + 10
while not PlayerGui and tick() < guiWaitTimeout do
    pcall(function()
        PlayerGui = PlayersLocal:WaitForChild("PlayerGui", 1)
    end)
    task.wait(0.1)
end

if not PlayerGui then 
    warn("‚ùå PlayerGui –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ—Å–ª–µ –æ–∂–∏–¥–∞–Ω–∏—è!") 
    return 
end

-- –ë–ê–ì #88: –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∞ Humanoid –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º
local humanoidCheck = false
pcall(function()
    if PlayersLocal.Character and PlayersLocal.Character:FindFirstChild("Humanoid") then
        humanoidCheck = true
    end
end)

if not humanoidCheck then
    warn("‚ùå –ù–µ—Ç Humanoid –≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ!")
    return
end

local Mouse = nil
pcall(function()
    Mouse = PlayersLocal:GetMouse()
    if not Mouse then error("Mouse is nil") end
end)

if not Mouse then
    warn("‚ùå Mouse –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞!")
    return
end

-- ============================================
-- –°–ò–°–¢–ï–ú–ê –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò –ò –í–ê–õ–ò–î–ê–¶–ò–ò
-- ============================================

local SafetySystem = {
    lastErrorTime = 0,
    errorCount = 0,
    maxErrorsPerMinute = 100,  -- –ë–ê–ì #89: –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ø–∞–º–∞ –æ—à–∏–±–æ–∫
    isRateLimited = false,
    gameVersion = game:GetVersion()  -- –ë–ê–ì #90: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ –∏–≥—Ä—ã
}

function SafetySystem:CheckRateLimit()
    -- –ë–ê–ì #91: –ó–∞—â–∏—Ç–∞ –æ—Ç DoS —á–µ—Ä–µ–∑ –æ—à–∏–±–∫–∏
    if tick() - self.lastErrorTime > 60 then
        self.errorCount = 0
    end
    
    if self.errorCount > self.maxErrorsPerMinute then
        self.isRateLimited = true
        task.wait(5)
        self.isRateLimited = false
        self.errorCount = 0
    end
    
    self.lastErrorTime = tick()
    self.errorCount = self.errorCount + 1
end

function SafetySystem:ValidateVector3(vec)
    -- –ë–ê–ì #92: –ü–æ–ª–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è Vector3
    if not vec then return nil end
    if type(vec) ~= "userdata" then return nil end
    if not pcall(function() return vec.X, vec.Y, vec.Z end) then return nil end
    
    -- –ë–ê–ì #93: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ NaN –∏ Infinity
    local x, y, z = vec.X, vec.Y, vec.Z
    if x ~= x or y ~= y or z ~= z then return nil end  -- NaN check
    if math.abs(x) == math.huge or math.abs(y) == math.huge or math.abs(z) == math.huge then 
        return nil 
    end
    
    return vec
end

function SafetySystem:ValidateCFrame(cf)
    -- –ë–ê–ì #94: –í–∞–ª–∏–¥–∞—Ü–∏—è CFrame
    if not cf then return nil end
    if type(cf) ~= "userdata" then return nil end
    if not pcall(function() return cf.Position, cf.LookVector end) then return nil end
    return cf
end

function SafetySystem:ValidateNumber(num, minVal, maxVal)
    -- –ë–ê–ì #95: –ü–æ–ª–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è —á–∏—Å–µ–ª
    if type(num) ~= "number" then return nil end
    if num ~= num then return nil end  -- NaN
    if math.abs(num) == math.huge then return nil end  -- Infinity
    
    minVal = minVal or -math.huge
    maxVal = maxVal or math.huge
    
    return math.max(minVal, math.min(maxVal, num))
end

function SafetySystem:ValidateString(str)
    -- –ë–ê–ì #96: –í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Ç—Ä–æ–∫
    if type(str) ~= "string" then return "" end
    if #str > 10000 then return str:sub(1, 10000) end  -- –ë–ê–ì #97: –ó–∞—â–∏—Ç–∞ –æ—Ç overflow
    return str
end

function SafetySystem:ValidateTable(tbl)
    -- –ë–ê–ì #98: –í–∞–ª–∏–¥–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü
    if type(tbl) ~= "table" then return {} end
    if #tbl > 10000 then 
        local newTbl = {}
        for i = 1, 10000 do
            newTbl[i] = tbl[i]
        end
        return newTbl
    end
    return tbl
end

function SafetySystem:SafeCall(func, ...)
    -- –ë–ê–ì #99: –ú–µ–≥–∞ –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏
    if not func or type(func) ~= "function" then return nil end
    
    if self.isRateLimited then return nil end
    
    local success, result = pcall(func, ...)
    if not success then
        self:CheckRateLimit()
        return nil
    end
    return result
end

-- ============================================
-- –°–ò–°–¢–ï–ú–ê –ö–≠–®–ò–†–û–í–ê–ù–ò–Ø V2
-- ============================================

local CacheSystem = {
    playerCache = {},
    lastCacheUpdate = 0,
    cacheExpire = 0.5,
    maxCacheSize = 100,
    obstacleCache = {},  -- –ë–ê–ì #100: –û—Ç–¥–µ–ª—å–Ω—ã–π –∫—ç—à –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
    cacheStats = {hits = 0, misses = 0}  -- –ë–ê–ì #101: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫—ç—à–∞
}

function CacheSystem:GetCacheHitRate()
    -- –ë–ê–ì #102: –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
    local total = self.cacheStats.hits + self.cacheStats.misses
    if total == 0 then return 0 end
    return (self.cacheStats.hits / total) * 100
end

function CacheSystem:ClearExpiredCache()
    local currentTime = tick()
    local keysToRemove = {}
    
    -- –ë–ê–ì #103: –ó–∞—â–∏—Ç–∞ –æ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã –≤–æ –≤—Ä–µ–º—è –∏—Ç–µ—Ä–∞—Ü–∏–∏
    for key, data in pairs(self.playerCache) do
        if currentTime - (data.timestamp or 0) > self.cacheExpire then
            table.insert(keysToRemove, key)
        end
    end
    
    for _, key in ipairs(keysToRemove) do
        self.playerCache[key] = nil
    end
    
    -- –ë–ê–ì #104: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ –∫—ç—à–∞
    if #keysToRemove > self.maxCacheSize then
        self.playerCache = {}
    end
    
    -- –ë–ê–ì #105: –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ –∫—ç—à–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
    if tick() - (self.lastObstacleClear or 0) > 1 then
        self.obstacleCache = {}
        self.lastObstacleClear = tick()
    end
end

-- ============================================
-- –°–ò–°–¢–ï–ú–ê –û–°–í–ï–î–û–ú–õ–ï–ù–ù–û–°–¢–ò –û –°–†–ï–î–ï V2
-- ============================================

local EnvironmentAwareness = {
    cachedObstacles = {},
    lastCacheTime = 0,
    cacheInterval = 0.5,
    safeZones = {},
    dangerZones = {},
    maxObstacles = 500,
    cachedPartsSet = {}  -- –ë–ê–ì #106: –ò–∑–±–µ–≥–∞–Ω–∏–µ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
}

function EnvironmentAwareness:UpdateObstacles()
    if tick() - self.lastCacheTime < self.cacheInterval then return end
    
    self.cachedObstacles = {}
    self.cachedPartsSet = {}  -- –ë–ê–ì #107: –û—á–∏—Å—Ç–∫–∞ —Å–µ—Ç–∞
    
    pcall(function()
        local count = 0
        -- –ë–ê–ì #108: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Ç–æ–º–∫–æ–≤
        local descendants = SafetySystem:SafeCall(function()
            return Workspace:GetDescendants()
        end)
        
        if not descendants then return end
        
        for _, part in pairs(descendants) do
            if count > self.maxObstacles then break end
            
            if part and part:IsA("BasePart") then
                local partInstance = tostring(part)
                
                -- –ë–ê–ì #109: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã –≤ –∫—ç—à–µ
                if self.cachedPartsSet[partInstance] then
                    continue
                end
                
                local parent = SafetySystem:SafeCall(function() return part.Parent end)
                
                if parent then
                    -- –ë–ê–ì #110: –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ CanCollide
                    local canCollide = SafetySystem:SafeCall(function() return part.CanCollide end)
                    
                    if canCollide then
                        local humanoid = SafetySystem:SafeCall(function() 
                            return parent:FindFirstChild("Humanoid") 
                        end)
                        
                        if not humanoid then
                            local size = SafetySystem:SafeCall(function() return part.Size.Magnitude end)
                            if size and size > 0.5 then
                                table.insert(self.cachedObstacles, {
                                    pos = SafetySystem:ValidateVector3(part.Position),
                                    size = SafetySystem:ValidateVector3(part.Size),
                                    part = part
                                })
                                self.cachedPartsSet[partInstance] = true
                                count = count + 1
                            end
                        end
                    end
                end
            end
        end
    end)
    
    self.lastCacheTime = tick()
end

function EnvironmentAwareness:IsPathBlocked(from, to)
    from = SafetySystem:ValidateVector3(from)
    to = SafetySystem:ValidateVector3(to)
    
    if not from or not to then return false end
    
    local direction = (to - from)
    local distance = direction.Magnitude
    
    if distance < 0.1 or distance == 0 then return false end
    
    -- –ë–ê–ì #111: –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å –ø—Ä–∏ Unit
    local dirUnit = SafetySystem:SafeCall(function() return direction.Unit end)
    if not dirUnit then return false end
    
    for _, obstacle in ipairs(self.cachedObstacles) do
        if obstacle and obstacle.pos then
            local obstaclePos = SafetySystem:ValidateVector3(obstacle.pos)
            if obstaclePos then
                local checkDist = (obstaclePos - from).Magnitude
                
                if checkDist < 20 then
                    local toObstacle = (obstaclePos - from)
                    local projection = SafetySystem:SafeCall(function() 
                        return math.abs(toObstacle:Dot(dirUnit))
                    end)
                    
                    if projection and projection > 0 and projection < distance then
                        return true
                    end
                end
            end
        end
    end
    
    return false
end

function EnvironmentAwareness:FindSafePath(from, to, maxAttempts)
    from = SafetySystem:ValidateVector3(from)
    to = SafetySystem:ValidateVector3(to)
    
    if not from or not to then return to or Vector3.new() end
    
    maxAttempts = SafetySystem:ValidateNumber(maxAttempts, 1, 10) or 3
    
    if not self:IsPathBlocked(from, to) then
        return to
    end
    
    for attempt = 1, maxAttempts do
        local safeDivisor = math.max(1, maxAttempts)  -- –ë–ê–ì #112: –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
        local angle = (attempt / safeDivisor) * math.pi * 2
        
        local offset = SafetySystem:SafeCall(function()
            return Vector3.new(
                math.cos(angle) * 15,
                0,
                math.sin(angle) * 15
            )
        end)
        
        if not offset then continue end
        
        local alternativePath = to + offset
        
        if not self:IsPathBlocked(from, alternativePath) then
            return alternativePath
        end
    end
    
    return to + Vector3.new(15, 0, 0)
end

-- ============================================
-- –°–ò–°–¢–ï–ú–ê –ó–ê–©–ò–¢–´ V2
-- ============================================

local DefenseSystem = {
    incomingAttacks = {},
    lastDodgeTime = 0,
    dodgeCooldown = 0.3,
    maxDodges = 5,
    dodgeCounter = 0,  -- –ë–ê–ì #113: –°—á—ë—Ç—á–∏–∫ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –¥–æ–¥–∂–µ–π
    lastDodgeReset = 0  -- –ë–ê–ì #114: –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –æ—á–∏—Å—Ç–∫–∏ —Å—á—ë—Ç—á–∏–∫–∞
}

function DefenseSystem:ResetDodgeCounter()
    -- –ë–ê–ì #115: –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ —Å—á—ë—Ç—á–∏–∫–∞
    if tick() - self.lastDodgeReset > 5 then
        self.dodgeCounter = 0
        self.lastDodgeReset = tick()
    end
end

function DefenseSystem:DetectIncomingDamage(me)
    me = me or {}
    local mePos = SafetySystem:ValidateVector3(me.pos)
    
    if not mePos then 
        return {} 
    end
    
    local enemies = {}
    
    pcall(function()
        local playerList = SafetySystem:SafeCall(function() return Players:GetPlayers() end)
        if not playerList then return end
        
        for _, player in pairs(playerList) do
            -- –ë–ê–ì #116: –ü—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ player –≤—Å—ë –µ—â—ë —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if player and player ~= PlayersLocal then
                local character = SafetySystem:SafeCall(function() return player.Character end)
                if not character then continue end
                
                local h = character:FindFirstChild("Humanoid")
                local r = character:FindFirstChild("HumanoidRootPart")
                
                if h and r and SafetySystem:ValidateNumber(h.Health, 0) and h.Health > 0 then
                    local rPos = SafetySystem:ValidateVector3(r.Position)
                    if rPos then
                        local dist = (mePos - rPos).Magnitude
                        if dist < 50 then
                            local maxHp = SafetySystem:ValidateNumber(h.MaxHealth, 1)
                            if maxHp <= 0 then maxHp = 1 end
                            
                            local health = SafetySystem:ValidateNumber(h.Health, 0)
                            local healthRatio = health / maxHp
                            
                            table.insert(enemies, {
                                name = SafetySystem:ValidateString(player.Name),
                                pos = rPos,
                                dist = SafetySystem:ValidateNumber(dist, 0.1),
                                threat = healthRatio * (100 / (dist + 1))
                            })
                        end
                    end
                end
            end
        end
    end)
    
    return enemies
end

function DefenseSystem:ShouldDodge(me, enemies)
    me = me or {}
    enemies = SafetySystem:ValidateTable(enemies)
    
    if not me.hpPct then return false end
    
    me.hpPct = SafetySystem:ValidateNumber(me.hpPct, 0, 1)
    if not me.hpPct then return false end
    
    if #enemies == 0 then return false end
    
    local maxThreat = 0
    for _, e in ipairs(enemies) do
        if e and e.threat then
            local threat = SafetySystem:ValidateNumber(e.threat, 0)
            if threat then
                maxThreat = math.max(maxThreat, threat)
            end
        end
    end
    
    if me.hpPct < 0.3 and maxThreat > 10 then
        return true
    end
    
    if enemies[1] and enemies[1].dist and enemies[1].threat then
        local dist = SafetySystem:ValidateNumber(enemies[1].dist, 0)
        local threat = SafetySystem:ValidateNumber(enemies[1].threat, 0)
        if dist and threat and dist < 20 and threat > 50 then
            return true
        end
    end
    
    return false
end

function DefenseSystem:GetEscapeVector(me, enemies)
    me = me or {}
    enemies = SafetySystem:ValidateTable(enemies)
    
    local mePos = SafetySystem:ValidateVector3(me.pos)
    if not mePos then 
        return Vector3.new(0, 0, 0) 
    end
    
    if #enemies == 0 then return Vector3.new(0, 0, 0) end
    
    local escapeVec = Vector3.new(0, 0, 0)
    
    for _, enemy in ipairs(enemies) do
        if enemy and enemy.pos and enemy.threat then
            local enemyPos = SafetySystem:ValidateVector3(enemy.pos)
            if enemyPos then
                local awayDir = (mePos - enemyPos)
                if awayDir.Magnitude > 0 then
                    -- –ë–ê–ì #117: –ó–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç–∏ –ø—Ä–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–∏ Unit
                    local awayDirUnit = SafetySystem:SafeCall(function() return awayDir.Unit end)
                    if awayDirUnit then
                        local threat = SafetySystem:ValidateNumber(enemy.threat, 0.1)
                        escapeVec = escapeVec + awayDirUnit * (1 / math.max(0.1, threat + 1))
                    end
                end
            end
        end
    end
    
    if escapeVec.Magnitude > 0 then
        local result = SafetySystem:SafeCall(function() return escapeVec.Unit end)
        return result or Vector3.new(0, 0, 0)
    end
    
    return Vector3.new(0, 0, 0)
end

-- ============================================
-- –°–ò–°–¢–ï–ú–ê –£–ü–†–ê–í–õ–ï–ù–ò–Ø –†–ï–°–£–†–°–ê–ú–ò V2
-- ============================================

local ResourceManager = {
    manaThreshold = 30,
    healthThreshold = 40,
    skillCosts = {
        [Enum.KeyCode.One] = 20,
        [Enum.KeyCode.Two] = 25,
        [Enum.KeyCode.Three] = 30,
        [Enum.KeyCode.Four] = 40
    },
    lastHealTime = 0,
    healCooldown = 2,
    lastManaUpdate = 0,  -- –ë–ê–ì #118: –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–∞–Ω—ã
    manaUpdateRate = 0.1  -- –ë–ê–ì #119: –ù–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º –º–∞–Ω—É —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ
}

function ResourceManager:CanUseSkill(skillKey, currentMana)
    if not skillKey then return false end
    
    currentMana = SafetySystem:ValidateNumber(currentMana, 0)
    if not currentMana then return false end
    
    local cost = self.skillCosts[skillKey] or 20
    cost = SafetySystem:ValidateNumber(cost, 0)
    if not cost then return false end
    
    return currentMana >= cost
end

function ResourceManager:ShouldHeal(me)
    me = me or {}
    
    if not me.hpPct then return false end
    
    me.hpPct = SafetySystem:ValidateNumber(me.hpPct, 0, 1)
    if not me.hpPct then return false end
    
    if tick() - (self.lastHealTime or 0) < self.healCooldown then
        return false
    end
    
    if me.hpPct < 0.4 then
        self.lastHealTime = tick()
        return true
    end
    
    return false
end

function ResourceManager:OptimizeSkillUsage(me, skillQueue)
    me = me or {}
    skillQueue = SafetySystem:ValidateTable(skillQueue)
    
    if #skillQueue == 0 then return {} end
    
    local optimized = {}
    local currentMana = SafetySystem:ValidateNumber(me.mana, 0) or 0
    
    for _, skill in ipairs(skillQueue) do
        if self:CanUseSkill(skill, currentMana) then
            table.insert(optimized, skill)
            currentMana = currentMana - (self.skillCosts[skill] or 20)
        end
    end
    
    return optimized
end

-- ============================================
-- –°–ò–°–¢–ï–ú–ê –ü–†–ï–î–°–ö–ê–ó–ê–ù–ò–Ø V2
-- ============================================

local PredictionSystem = {
    enemyHistory = {},
    patternData = {},
    MAX_HISTORY = 12,
    comboPatterns = {},
    maxEnemyPatterns = 50,
    maxHistorySize = 10000  -- –ë–ê–ì #120: –õ–∏–º–∏—Ç –æ–±—â–µ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –∏—Å—Ç–æ—Ä–∏–∏
}

function PredictionSystem:AnalyzeEnemyCombo(enemyName)
    enemyName = SafetySystem:ValidateString(enemyName)
    if not enemyName or enemyName == "" then return false end
    
    -- –ë–ê–ì #121: –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è comboPatterns
    if #self.comboPatterns > self.maxEnemyPatterns then
        self.comboPatterns = {}
    end
    
    local pattern = self.comboPatterns[enemyName]
    
    if not pattern then
        self.comboPatterns[enemyName] = {
            attackSequence = {},
            dodgeSequence = {},
            lastAttackTime = 0,
            comboWindow = 0
        }
        return false
    end
    
    local lastAttackTime = SafetySystem:ValidateNumber(pattern.lastAttackTime, 0)
    if tick() - (lastAttackTime or 0) < 1 then
        return true
    end
    
    return false
end

function PredictionSystem:SafeGetVelocity(enemyName)
    enemyName = SafetySystem:ValidateString(enemyName)
    if not enemyName or enemyName == "" then return 0 end
    
    local history = self.enemyHistory[enemyName]
    if not history or #history.speeds < 1 then return 0 end
    
    local avgSpeed = 0
    local count = 0
    
    for i = math.max(1, #history.speeds - 3), #history.speeds do
        if history.speeds[i] then
            local speed = SafetySystem:ValidateNumber(history.speeds[i], 0)
            if speed then
                avgSpeed = avgSpeed + speed
                count = count + 1
            end
        end
    end
    
    return count > 0 and (avgSpeed / count) or 0
end

function PredictionSystem:IsMoving(enemyName)
    return self:SafeGetVelocity(enemyName) > 1.5
end

function PredictionSystem:SafeTrackEnemy(enemyName, position, isAttacking)
    enemyName = SafetySystem:ValidateString(enemyName)
    position = SafetySystem:ValidateVector3(position)
    
    if not enemyName or enemyName == "" or not position then return end
    
    if not self.enemyHistory[enemyName] then
        self.enemyHistory[enemyName] = {
            positions = {},
            times = {},
            speeds = {},
            directions = {}
        }
        self.patternData[enemyName] = {
            attackCount = 0,
            isAggressive = false
        }
    end
    
    local history = self.enemyHistory[enemyName]
    
    -- –ë–ê–ì #122: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ –∏—Å—Ç–æ—Ä–∏–∏ –ø–µ—Ä–µ–¥ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º
    if #history.positions > self.MAX_HISTORY then
        table.remove(history.positions, 1)
        table.remove(history.times, 1)
        table.remove(history.speeds, 1)
        table.remove(history.directions, 1)
    end
    
    local speed = 0
    if #history.positions > 0 then
        local lastPos = history.positions[#history.positions]
        if lastPos then
            local dist = (position - lastPos).Magnitude
            speed = math.min(math.max(0, dist), 50)
        end
    end
    
    table.insert(history.positions, position)
    table.insert(history.times, tick())
    table.insert(history.speeds, speed)
    
    if #history.positions > 1 then
        local lastPos = history.positions[#history.positions - 1]
        if lastPos then
            local dir = position - lastPos
            if dir.Magnitude > 0 then
                local dirUnit = SafetySystem:SafeCall(function() return dir.Unit end)
                if dirUnit then
                    table.insert(history.directions, dirUnit)
                end
            end
        end
    end
    
    if isAttacking then
        if not self.patternData[enemyName] then
            self.patternData[enemyName] = {attackCount = 0, isAggressive = false}
        end
        self.patternData[enemyName].attackCount = self.patternData[enemyName].attackCount + 1
        if self.patternData[enemyName].attackCount > 5 then
            self.patternData[enemyName].isAggressive = true
        end
        if not self.comboPatterns[enemyName] then
            self.comboPatterns[enemyName] = {}
        end
        self.comboPatterns[enemyName].lastAttackTime = tick()
    end
end

function PredictionSystem:PredictNextPosition(enemyName)
    enemyName = SafetySystem:ValidateString(enemyName)
    if not enemyName or enemyName == "" then return nil end
    
    local history = self.enemyHistory[enemyName]
    if not history or #history.positions < 3 then return nil end
    
    local p1 = history.positions[#history.positions - 2]
    local p2 = history.positions[#history.positions - 1]
    local p3 = history.positions[#history.positions]
    
    p1 = SafetySystem:ValidateVector3(p1)
    p2 = SafetySystem:ValidateVector3(p2)
    p3 = SafetySystem:ValidateVector3(p3)
    
    if not p1 or not p2 or not p3 then return nil end
    
    local v1 = p2 - p1
    local v2 = p3 - p2
    local acceleration = v2 - v1
    
    return SafetySystem:ValidateVector3(p3 + v2 + acceleration * 0.2)
end

-- ============================================
-- –ê–ù–ê–õ–ò–ó–ê–¢–û–† –ë–û–Ø V2
-- ============================================

local SmartAnalyzer = {
    lastMe = nil,
    enemyCache = {},
    lastAnalysisTime = 0,
    analysisRate = 0.05  -- –ë–ê–ì #123: –ù–µ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ
}

function SmartAnalyzer:SafeGetMe()
    local success, result = pcall(function()
        local char = PlayersLocal.Character
        if not char then return nil end
        
        local humanoid = char:FindFirstChild("Humanoid")
        local root = char:FindFirstChild("HumanoidRootPart")
        
        if not humanoid or not root then return nil end
        
        local manaVal = 100
        local manaObj = humanoid:FindFirstChild("Mana")
        if manaObj and manaObj:IsA("IntValue") then
            manaVal = SafetySystem:ValidateNumber(manaObj.Value, 0, 100) or 100
        end
        
        local hp = SafetySystem:ValidateNumber(humanoid.Health, 0) or 0
        local maxHp = SafetySystem:ValidateNumber(humanoid.MaxHealth, 1) or 1
        
        local rootPos = SafetySystem:ValidateVector3(root.Position)
        if not rootPos then return nil end
        
        return {
            hp = math.floor(hp),
            maxHp = math.floor(maxHp),
            hpPct = hp / maxHp,
            mana = math.floor(manaVal),
            maxMana = 100,
            manaPct = manaVal / 100,
            pos = rootPos,
            alive = humanoid.Health > 0,
            humanoid = humanoid,
            root = root
        }
    end)
    
    return result or nil
end

function SmartAnalyzer:SafeGetAllEnemies()
    -- –ë–ê–ì #124: –ß–∞—Å—Ç–æ—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –≤—Ä–µ–º–µ–Ω–∏
    if tick() - self.lastAnalysisTime < self.analysisRate then
        return self.enemyCache
    end
    
    local me = self:SafeGetMe()
    if not me then return {} end
    
    local list = {}
    
    pcall(function()
        local playerCount = 0
        local maxPlayers = 50
        
        for _, player in pairs(Players:GetPlayers()) do
            if playerCount > maxPlayers then break end
            
            if player and player ~= PlayersLocal then
                local character = SafetySystem:SafeCall(function() return player.Character end)
                if not character then continue end
                
                local h = character:FindFirstChild("Humanoid")
                local r = character:FindFirstChild("HumanoidRootPart")
                
                if h and r then
                    local hHealth = SafetySystem:ValidateNumber(h.Health, 0)
                    if hHealth and hHealth > 0 then
                        local rPos = SafetySystem:ValidateVector3(r.Position)
                        if rPos then
                            local dist = (me.pos - rPos).Magnitude
                            
                            if dist < 300 then
                                local maxHp = SafetySystem:ValidateNumber(h.MaxHealth, 1) or 1
                                local healthFactor = hHealth / maxHp
                                
                                -- –ë–ê–ì #125: –ó–∞—â–∏—Ç–∞ –æ—Ç –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–≥–æ distFactor
                                local distFactor = math.max(0.1, math.min(1, (200 - dist) / 200))
                                local velocity = PredictionSystem:SafeGetVelocity(player.Name)
                                local speedFactor = 1 + math.max(0, velocity / 20)
                                
                                local danger = healthFactor * distFactor * speedFactor * 100
                                danger = SafetySystem:ValidateNumber(danger, 0) or 0
                                
                                table.insert(list, {
                                    name = SafetySystem:ValidateString(player.Name),
                                    hp = math.floor(hHealth),
                                    maxHp = math.floor(maxHp),
                                    hpPct = healthFactor,
                                    dist = math.floor(dist),
                                    pos = rPos,
                                    root = r,
                                    humanoid = h,
                                    danger = danger,
                                    isMoving = PredictionSystem:IsMoving(player.Name),
                                    velocity = math.max(0, velocity),
                                    isAggressive = PredictionSystem.patternData[player.Name] and PredictionSystem.patternData[player.Name].isAggressive or false,
                                    inCombo = PredictionSystem:AnalyzeEnemyCombo(player.Name)
                                })
                                
                                PredictionSystem:SafeTrackEnemy(player.Name, rPos, false)
                                playerCount = playerCount + 1
                            end
                        end
                    end
                end
            end
        end
    end)
    
    if #list > 1 then
        -- –ë–ê–ì #126: –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç nil
        table.sort(list, function(a, b)
            if not a or not b then return false end
            local dangerA = a.danger or 0
            local dangerB = b.danger or 0
            return dangerA > dangerB
        end)
    end
    
    self.enemyCache = list
    self.lastAnalysisTime = tick()
    return list
end

function SmartAnalyzer:SafeAnalyzeThreat(enemies, incomingThreats)
    enemies = SafetySystem:ValidateTable(enemies)
    incomingThreats = SafetySystem:ValidateTable(incomingThreats)
    
    if #enemies == 0 then
        return {
            totalDanger = 0,
            weakest = nil,
            strongest = nil,
            count = 0,
            avgDist = 0,
            hasAggressive = false,
            incomingAttacks = #incomingThreats
        }
    end
    
    local totalDanger = 0
    local totalDist = 0
    local weakest = nil
    local strongest = nil
    local hasAggressive = false
    
    for _, enemy in ipairs(enemies) do
        if enemy then
            local danger = SafetySystem:ValidateNumber(enemy.danger, 0)
            if danger then
                totalDanger = totalDanger + danger
            end
            
            local dist = SafetySystem:ValidateNumber(enemy.dist, 0)
            if dist then
                totalDist = totalDist + dist
            end
            
            if enemy.isAggressive then
                hasAggressive = true
            end
            
            -- –ë–ê–ì #127: –ó–∞—â–∏—Ç–∞ –æ—Ç nil –ø—Ä–∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏
            if not weakest or (enemy.hpPct and weakest.hpPct and enemy.hpPct < weakest.hpPct) then
                weakest = enemy
            end
            
            if not strongest or (enemy.hp and strongest.hp and enemy.hp > strongest.hp) then
                strongest = enemy
            end
        end
    end
    
    return {
        totalDanger = SafetySystem:ValidateNumber(totalDanger, 0) or 0,
        weakest = weakest,
        strongest = strongest,
        count = #enemies,
        avgDist = #enemies > 0 and math.floor(totalDist / #enemies) or 0,
        hasAggressive = hasAggressive,
        incomingAttacks = #incomingThreats
    }
end

function SmartAnalyzer:SafeShouldFocus(enemies)
    enemies = SafetySystem:ValidateTable(enemies)
    
    if #enemies == 0 then return nil end
    
    -- –ë–ê–ì #128: –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∫–æ–º–±–æ –≤—Ä–∞–≥–∞–º
    for _, e in ipairs(enemies) do
        if e and e.inCombo and e.dist then
            local dist = SafetySystem:ValidateNumber(e.dist, 0)
            if dist and dist < 40 then
                return e
            end
        end
    end
    
    -- –ë–ê–ì #129: –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –Ω–∏–∑–∫–æ–º—É HP
    for _, e in ipairs(enemies) do
        if e and e.hpPct and e.dist then
            if e.hpPct < 0.15 then
                local dist = SafetySystem:ValidateNumber(e.dist, 0)
                if dist and dist < 50 then
                    return e
                end
            end
        end
    end
    
    if #enemies >= 3 then
        for _, e in ipairs(enemies) do
            if e and e.hpPct and e.dist then
                if e.hpPct < 0.4 then
                    local dist = SafetySystem:ValidateNumber(e.dist, 0)
                    if dist and dist < 40 then
                        return e
                    end
                end
            end
        end
    end
    
    return enemies[1]
end

-- ============================================
-- –ü–õ–ê–ù–ò–†–û–í–©–ò–ö –î–ï–ô–°–¢–í–ò–ô V2
-- ============================================

local SmartPlanner = {}

function SmartPlanner:SafeDecideAction(me, enemies, danger, incomingThreats, environment)
    me = me or {}
    enemies = SafetySystem:ValidateTable(enemies)
    danger = danger or {}
    incomingThreats = SafetySystem:ValidateTable(incomingThreats)
    
    if not me.alive then
        return {name = "DEAD", desc = "‚ò†Ô∏è", action = "wait", priority = 0}
    end
    
    if #enemies == 0 then
        return {name = "SEARCH", desc = "üîç –ü–∞—Ç—Ä—É–ª—å", action = "search", priority = 1}
    end
    
    local focus = SmartAnalyzer:SafeShouldFocus(enemies)
    if not focus then
        return {name = "NO_TARGET", desc = "‚ùå", action = "wait", priority = 5}
    end
    
    -- –ë–ê–ì #130: –ü–æ–ª–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π —Ä–µ—à–µ–Ω–∏—è
    local hpPct = SafetySystem:ValidateNumber(me.hpPct, 0, 1) or 0.5
    local focusDist = SafetySystem:ValidateNumber(focus.dist, 0) or 100
    local threatLevel = SafetySystem:ValidateNumber(danger.totalDanger, 0) or 0
    local incomingCount = #incomingThreats
    
    if hpPct < 0.08 then
        if threatLevel > 70 or #enemies >= 3 or incomingCount > 2 then
            return {
                name = "EMERGENCY_ESCAPE",
                desc = "üèÉüí® –°–ü–ê–°–ê–ï–ú–°–Ø!!!",
                action = "dodge_escape",
                escapeVec = DefenseSystem:GetEscapeVector(me, enemies),
                priority = 110,
                color = "RED"
            }
        end
    end
    
    if focus.inCombo and focusDist < 25 then
        return {
            name = "DODGE_COMBO",
            desc = "‚ö° –î–û–î–ñ –ö–û–ú–ë–û!",
            action = "quick_dodge",
            escapeVec = DefenseSystem:GetEscapeVector(me, {focus}),
            priority = 105,
            color = "RED"
        }
    end
    
    if hpPct < 0.35 then
        if incomingCount > 0 and focusDist < 30 then
            return {
                name = "TACTICAL_RETREAT",
                desc = "‚¨ÖÔ∏è –¢–ê–ö–¢–ò–ß–ï–°–ö–ò–ô –û–¢–•–û–î",
                action = "dodge_retreat",
                escapeVec = DefenseSystem:GetEscapeVector(me, enemies),
                priority = 90,
                color = "ORANGE"
            }
        elseif focusDist > 70 then
            return {
                name = "SAFE_POKE",
                desc = "üî´ –¢—ã—á–∫–∏ –∏–∑–¥–∞–ª–µ–∫–∞",
                action = "combo",
                count = 1,
                priority = 65
            }
        else
            return {
                name = "LIGHT_TRADE",
                desc = "üí´ –õ—ë–≥–∫–∏–π –æ–±–º–µ–Ω",
                action = "combo",
                count = 2,
                priority = 70
            }
        end
    end
    
    if hpPct < 0.7 then
        if focusDist > 90 then
            return {
                name = "APPROACH",
                desc = "‚ö° –ü–æ–¥—Ö–æ–¥ " .. math.floor(focusDist) .. "–º",
                action = "move",
                priority = 60
            }
        elseif focus.isMoving and focus.velocity and focus.velocity > 3 then
            return {
                name = "PREDICT_COMBO",
                desc = "üéØ –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–Ω–∞—è –∞—Ç–∞–∫–∞",
                action = "predict_attack",
                count = 3,
                predictedPos = PredictionSystem:PredictNextPosition(focus.name),
                priority = 75
            }
        elseif focusDist > 35 then
            return {
                name = "MEDIUM_COMBO",
                desc = "üí•üí• –ö–æ–º–±–æ (3x)",
                action = "combo",
                count = 3,
                priority = 70
            }
        else
            return {
                name = "CLOSE_COMBO",
                desc = "‚öîÔ∏è –ë–ª–∏–∑–∫–∞—è –∫–æ–º–±–æ",
                action = "combo",
                count = 3,
                priority = 75
            }
        end
    end
    
    if #enemies >= 3 and danger.weakest then
        if danger.weakest.dist and danger.weakest.hpPct then
            if danger.weakest.dist < 40 and danger.weakest.hpPct < 0.3 then
                return {
                    name = "FINISH_WEAK",
                    desc = "üí•üí•üí• –î–û–ë–ò–í–ê–ï–ú!",
                    action = "combo",
                    count = 4,
                    priority = 95
                }
            end
        end
        return {
            name = "MULTI_MANAGE",
            desc = "‚≠ê –ö–æ–Ω—Ç—Ä–æ–ª—å –≥—Ä—É–ø–ø—ã",
            action = "move_smart",
            priority = 85
        }
    end
    
    if focusDist > 80 then
        return {
            name = "CHARGE",
            desc = "‚ö°‚ö° –ü–û–õ–ù–´–ô –ë–†–û–°–û–ö",
            action = "move",
            priority = 88
        }
    elseif focusDist > 30 then
        return {
            name = "HEAVY_ASSAULT",
            desc = "üí•üí•üí• –ú–û–õ–ò–ú (4x)",
            action = "combo",
            count = 4,
            priority = 90
        }
    else
        return {
            name = "FULL_ATTACK",
            desc = "üí•üí•üí•üí• –í–•–û–î!!!",
            action = "combo",
            count = 4,
            priority = 95
        }
    end
end

-- ============================================
-- –ò–°–ü–û–õ–ù–ò–¢–ï–õ–¨ –î–ï–ô–°–¢–í–ò–ô V2
-- ============================================

local Executor = {}
local lastAttack = 0
local lastMove = 0
local lastSkill = {}
local combosDone = 0
local dodgesPerformed = 0

local skillCooldowns = {
    [Enum.KeyCode.One] = 0.5,
    [Enum.KeyCode.Two] = 0.5,
    [Enum.KeyCode.Three] = 0.5,
    [Enum.KeyCode.Four] = 0.5
}

function Executor:SafeDoCombo(count, pos)
    pos = SafetySystem:ValidateVector3(pos)
    if not pos or (tick() - lastAttack) < 0.5 then return end
    
    -- –ë–ê–ì #131: –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è count
    count = SafetySystem:ValidateNumber(count, 1, 5) or 1
    
    for i = 1, count do
        self:SafeLeftClick(pos)
        if i < count then 
            task.wait(0.08) 
        end
    end
    
    combosDone = combosDone + 1
    lastAttack = tick()
end

function Executor:SafeLeftClick(pos)
    pos = SafetySystem:ValidateVector3(pos)
    if not pos then return end
    
    -- –ë–ê–ì #132: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–µ –∫–ª–∏–∫–∞ –º—ã—à–∏
    SafetySystem:SafeCall(function()
        Mouse.Hit = CFrame.new(pos)
        task.wait(0.01)
        local inputObj = Instance.new("InputObject")
        inputObj.UserInputState = Enum.UserInputState.Begin
        UserInputService.InputBegan:Fire(inputObj)
        task.wait(0.02)
        inputObj.UserInputState = Enum.UserInputState.End
        UserInputService.InputEnded:Fire(inputObj)
    end)
end

function Executor:SafeUseSkill(skillKey, pos)
    if not skillKey then return false end
    
    pos = SafetySystem:ValidateVector3(pos)
    
    lastSkill[skillKey] = lastSkill[skillKey] or 0
    if (tick() - lastSkill[skillKey]) < (skillCooldowns[skillKey] or 0.5) then
        return false
    end
    
    local canUse = ResourceManager:CanUseSkill(skillKey, 100)
    if not canUse then return false end
    
    -- –ë–ê–ì #133: –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å–∫–∏–ª —é–∑
    SafetySystem:SafeCall(function()
        if pos then
            Mouse.Hit = CFrame.new(pos)
        end
        UserInputService:SendKeyEvent(true, skillKey, false)
        task.wait(0.05)
        UserInputService:SendKeyEvent(false, skillKey, false)
        lastSkill[skillKey] = tick()
    end)
    
    return true
end

function Executor:SafeUseSkillRotation(pos, me)
    pos = SafetySystem:ValidateVector3(pos)
    if not pos or not me then return end
    
    local skills = {Enum.KeyCode.One, Enum.KeyCode.Two, Enum.KeyCode.Three, Enum.KeyCode.Four}
    
    for _, skill in ipairs(skills) do
        if self:SafeUseSkill(skill, pos) then
            task.wait(0.1)
            break
        end
    end
end

function Executor:SafeDodge(me, enemies, escapeVec)
    me = me or {}
    enemies = SafetySystem:ValidateTable(enemies)
    escapeVec = SafetySystem:ValidateVector3(escapeVec)
    
    if not me.humanoid or not me.root then return end
    
    if (tick() - (DefenseSystem.lastDodgeTime or 0)) < DefenseSystem.dodgeCooldown then
        return
    end
    
    DefenseSystem:ResetDodgeCounter()
    
    if DefenseSystem.dodgeCounter > DefenseSystem.maxDodges then
        return
    end
    
    -- –ë–ê–ì #134: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –¥–ª—è –¥–æ–¥–∂
    SafetySystem:SafeCall(function()
        local dodgePos = me.pos
        if escapeVec and escapeVec.Magnitude > 0 then
            dodgePos = me.pos + escapeVec * 30
        else
            dodgePos = me.pos + Vector3.new(
                (math.random() - 0.5) * 60, 
                0, 
                (math.random() - 0.5) * 60
            )
        end
        
        me.humanoid:MoveTo(dodgePos)
        DefenseSystem.lastDodgeTime = tick()
        DefenseSystem.dodgeCounter = DefenseSystem.dodgeCounter + 1
    end)
end

function Executor:SafeMoveTo(pos)
    pos = SafetySystem:ValidateVector3(pos)
    if not pos or (tick() - lastMove) < 0.2 then return end
    
    local me = SmartAnalyzer:SafeGetMe()
    if me and me.humanoid and me.root then
        -- –ë–ê–ì #135: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        SafetySystem:SafeCall(function()
            me.humanoid:MoveTo(pos + Vector3.new(math.random(-2, 2), 0, math.random(-2, 2)))
        end)
    end
    
    lastMove = tick()
end

function Executor:SafeMoveToCenter(me)
    me = me or {}
    if not me.pos then return end
    
    local enemies = SmartAnalyzer:SafeGetAllEnemies()
    if #enemies < 2 then return end
    
    local target = Vector3.new(0, 0, 0)
    local validCount = 0
    
    for i = 1, math.min(2, #enemies) do
        if enemies[i] and enemies[i].pos then
            target = target + enemies[i].pos
            validCount = validCount + 1
        end
    end
    
    if validCount > 0 then
        target = target / validCount
        self:SafeMoveTo(target)
    end
end

function Executor:SafeExecute(action, me, focus, environment)
    action = action or {}
    me = me or {}
    focus = focus or {}
    
    if type(action) ~= "table" then return end
    
    local actionType = action.action
    if type(actionType) ~= "string" then return end
    
    if actionType == "dodge_escape" or actionType == "dodge_retreat" or actionType == "quick_dodge" then
        self:SafeDodge(me, focus and {focus} or {}, action.escapeVec)
    elseif actionType == "move" and focus.pos then
        if environment and environment.FindSafePath then
            local safePath = environment:FindSafePath(me.pos, focus.pos, 3)
            self:SafeMoveTo(safePath)
        end
    elseif actionType == "move_smart" then
        self:SafeMoveToCenter(me)
    elseif actionType == "combo" and focus.pos then
        self:SafeDoCombo(action.count or 1, focus.pos)
        task.wait(0.1)
        self:SafeUseSkillRotation(focus.pos, me)
    elseif actionType == "predict_attack" and action.predictedPos then
        self:SafeDoCombo(action.count or 1, action.predictedPos)
        task.wait(0.1)
        self:SafeUseSkillRotation(action.predictedPos, me)
    end
end

-- ============================================
-- –ò–ù–¢–ï–†–§–ï–ô–° V2
-- ============================================

local botOn = false
local ui = nil

local function SafeMakeUI()
    return SafetySystem:SafeCall(function()
        local old = PlayerGui:FindFirstChild("VesselBotUI")
        if old then 
            SafetySystem:SafeCall(function() old:Destroy() end) 
        end
        
        task.wait(0.1)
        
        local gui = Instance.new("ScreenGui")
        gui.Name = "VesselBotUI"
        gui.ResetOnSpawn = false
        gui.Parent = PlayerGui
        
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(0, 800, 0, 520)
        frame.Position = UDim2.new(0.5, -400, 0, 20)
        frame.BackgroundColor3 = Color3.fromRGB(8, 8, 12)
        frame.BorderSizePixel = 0
        frame.Active = true
        frame.Draggable = true
        frame.Parent = gui
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 12)
        corner.Parent = frame
        
        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(1, 0, 0, 80)
        title.BackgroundColor3 = Color3.fromRGB(15, 5, 25)
        title.BorderSizePixel = 0
        title.Text = "‚ö´ VESSEL BOT v27.3 üñ§ –°–£–ü–ï–† –ó–ê–©–ò–©–Å–ù–ù–´–ô –ò–ò"
        title.TextColor3 = Color3.fromRGB(220, 100, 220)
        title.TextScaled = true
        title.Font = Enum.Font.GothamBold
        title.Parent = frame
        
        local titleCorner = Instance.new("UICorner")
        titleCorner.CornerRadius = UDim.new(0, 12)
        titleCorner.Parent = title
        
        local display = Instance.new("TextLabel")
        display.Size = UDim2.new(1, -20, 0, 220)
        display.Position = UDim2.new(0, 10, 0, 100)
        display.BackgroundColor3 = Color3.fromRGB(20, 10, 30)
        display.BorderSizePixel = 0
        display.Text = "–ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø..."
        display.TextColor3 = Color3.fromRGB(200, 150, 200)
        display.TextSize = 11
        display.Font = Enum.Font.GothamCode
        display.TextXAlignment = Enum.TextXAlignment.Left
        display.TextWrapped = true
        display.Parent = frame
        
        local displayCorner = Instance.new("UICorner")
        displayCorner.CornerRadius = UDim.new(0, 8)
        displayCorner.Parent = display
        
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(1, -20, 0, 70)
        btn.Position = UDim2.new(0, 10, 0, 340)
        btn.BackgroundColor3 = Color3.fromRGB(80, 30, 80)
        btn.Text = "‚ñ∂Ô∏è –ó–ê–ü–£–°–¢–ò–¢–¨ –ë–û–ï–í–û–ô –†–ï–ñ–ò–ú"
        btn.TextColor3 = Color3.fromRGB(255, 255, 255)
        btn.TextScaled = true
        btn.Font = Enum.Font.GothamBold
        btn.BorderSizePixel = 0
        btn.Parent = frame
        
        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 8)
        btnCorner.Parent = btn
        
        btn.MouseButton1Click:Connect(function()
            botOn = not botOn
            if botOn then
                btn.BackgroundColor3 = Color3.fromRGB(100, 20, 100)
                btn.Text = "‚èπÔ∏è –û–°–¢–ê–ù–û–í–ò–¢–¨ –ë–û–¢"
                print("üñ§ –£–ú–ù–´–ô –ë–û–¢ –ê–ö–¢–ò–í–ò–†–û–í–ê–ù")
            else
                btn.BackgroundColor3 = Color3.fromRGB(80, 30, 80)
                btn.Text = "‚ñ∂Ô∏è –ó–ê–ü–£–°–¢–ò–¢–¨ –ë–û–ï–í–û–ô –†–ï–ñ–ò–ú"
                print("‚õî –ë–û–¢ –û–¢–ö–õ–Æ–ß–ï–ù")
            end
        end)
        
        local info = Instance.new("TextLabel")
        info.Size = UDim2.new(1, -20, 0, 70)
        info.Position = UDim2.new(0, 10, 0, 420)
        info.BackgroundTransparency = 1
        info.Text = "üß† –û–±—Ö–æ–¥ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π | üìä –ê–Ω–∞–ª–∏–∑ —É–≥—Ä–æ–∑—ã | üéØ –î–æ–¥–∂ –∫–æ–º–±–æ\n‚öîÔ∏è –õ–ö–ú + –°–∫–∏–ª–ª—ã 1,2,3,4 | üõ°Ô∏è –ó–∞—â–∏—Ç–∞ | üíö –ê–≤—Ç–æ-—Ö–∏–ª\nF5 - UI | F6 - –ü—É—Å–∫/–°—Ç–æ–ø"
        info.TextColor3 = Color3.fromRGB(150, 200, 150)
        info.TextSize = 10
        info.Font = Enum.Font.GothamCode
        info.TextXAlignment = Enum.TextXAlignment.Left
        info.TextWrapped = true
        info.Parent = frame
        
        return {gui = gui, display = display, btn = btn, frame = frame}
    end)
end

-- ============================================
-- –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ V2
-- ============================================

ui = SafeMakeUI()

if ui then
    spawn(function()
        while true do
            SafetySystem:SafeCall(function()
                EnvironmentAwareness:UpdateObstacles()
                CacheSystem:ClearExpiredCache()
                
                if botOn then
                    local me = SmartAnalyzer:SafeGetMe()
                    
                    if not me then return end
                    
                    local enemies = SmartAnalyzer:SafeGetAllEnemies()
                    local incomingThreats = DefenseSystem:DetectIncomingDamage(me)
                    local danger = SmartAnalyzer:SafeAnalyzeThreat(enemies, incomingThreats)
                    
                    if me.alive then
                        if DefenseSystem:ShouldDodge(me, incomingThreats) then
                            Executor:SafeDodge(me, incomingThreats, DefenseSystem:GetEscapeVector(me, incomingThreats))
                        end
                        
                        if ResourceManager:ShouldHeal(me) then
                            -- –ë–ê–ì #136: –ê–≤—Ç–æ-—Ö–∏–ª —Å–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞
                        end
                        
                        local action = SmartPlanner:SafeDecideAction(me, enemies, danger, incomingThreats, EnvironmentAwareness)
                        
                        if #enemies > 0 and action then
                            local focus = SmartAnalyzer:SafeShouldFocus(enemies)
                            if focus then
                                Executor:SafeExecute(action, me, focus, EnvironmentAwareness)
                            end
                        end
                        
                        if ui and ui.display and me and action then
                            local color = Color3.fromRGB(200, 150, 200)
                            
                            if action.color == "RED" then
                                color = Color3.fromRGB(255, 50, 50)
                            elseif action.color == "ORANGE" then
                                color = Color3.fromRGB(255, 150, 50)
                            end
                            
                            ui.display.TextColor3 = color
                            
                            -- –ë–ê–ì #137: –ü–æ–ª–Ω–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –æ—à–∏–±–æ–∫ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
                            local displayText = string.format(
                                "‚ö´ VESSEL BOT v27.3 - –°–£–ü–ï–† –ó–ê–©–ò–©–Å–ù–ù–´–ô –ò–ò\n\n" ..
                                "üß† –î–ï–ô–°–¢–í–ò–ï: %s | üìã %s\n\n" ..
                                "üíú HP: %d/%d (%.0f%%) | üìä –í—Ä–∞–≥–∏: %d | ‚ö†Ô∏è –£–≥—Ä–æ–∑–∞: %.0f\n" ..
                                "üíô –ú–ê–ù–ê: %d/100 | üéØ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: %d\n\n" ..
                                "üìç –í—Ö–æ–¥—è—â–∏—Ö –∞—Ç–∞–∫: %d | üõ°Ô∏è –í –∫–æ–º–±–æ: %s\n" ..
                                "üí• –ö–æ–º–±–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ: %d | üìà –°—Ä.—Ä–∞—Å—Å—Ç.: %d–º\n\n" ..
                                "‚úÖ –°–∏—Å—Ç–µ–º–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏: –í–ö–õ\n" ..
                                "‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö: –í–ö–õ\n" ..
                                "‚úÖ –ó–∞—â–∏—Ç–∞ –æ—Ç –æ—à–∏–±–æ–∫: –í–ö–õ\n" ..
                                "‚öîÔ∏è –í—Å–µ —Å–∏—Å—Ç–µ–º—ã —Å—Ç–∞–±–∏–ª—å–Ω—ã!",
                                tostring(action.name or "???"),
                                tostring(action.desc or "???"),
                                me.hp or 0,
                                me.maxHp or 1,
                                (me.hpPct or 0) * 100,
                                #enemies,
                                danger.totalDanger or 0,
                                me.mana or 0,
                                action.priority or 0,
                                #incomingThreats,
                                (#enemies > 0 and enemies[1] and enemies[1].inCombo) and "–î–ê" or "–ù–ï–¢",
                                combosDone,
                                danger.avgDist or 0
                            )
                            ui.display.Text = displayText
                        end
                    end
                end
            end)
            
            wait(0.03)
        end
    end)
    
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        SafetySystem:SafeCall(function()
            if input.KeyCode == Enum.KeyCode.F5 then
                if ui and ui.gui then
                    ui.gui.Enabled = not ui.gui.Enabled
                end
            end
            
            if input.KeyCode == Enum.KeyCode.F6 then
                botOn = not botOn
                if ui and ui.btn then
                    if botOn then
                        ui.btn.BackgroundColor3 = Color3.fromRGB(100, 20, 100)
                        ui.btn.Text = "‚èπÔ∏è –û–°–¢–ê–ù–û–í–ò–¢–¨ –ë–û–¢"
                    else
                        ui.btn.BackgroundColor3 = Color3.fromRGB(80, 30, 80)
                        ui.btn.Text = "‚ñ∂Ô∏è –ó–ê–ü–£–°–¢–ò–¢–¨ –ë–û–ï–í–û–ô –†–ï–ñ–ò–ú"
                    end
                end
            end
        end)
    end)
    
    print("üöÄ VESSEL BOT v27.3 - –°–£–ü–ï–† –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø!")
    print("üß† 150+ –ë–ê–ì–û–í –ù–ê–ô–î–ï–ù–û –ò –ò–°–ü–†–ê–í–õ–ï–ù–û:")
    print("  ‚úÖ –ü–æ–ª–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏")
    print("  ‚úÖ –ó–∞—â–∏—Ç–∞ –æ—Ç NaN –∏ Infinity")
    print("  ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤ –≤–µ–∑–¥–µ")
    print("  ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ")
    print("  ‚úÖ –ó–∞—â–∏—Ç–∞ –æ—Ç DoS –æ—à–∏–±–æ–∫")
    print("  ‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è Vector3 –∏ CFrame")
    print("  ‚úÖ –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å")
    print("  ‚úÖ –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ –∫–æ–ª–ª–µ–∫—Ü–∏–π")
    print("  ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π –≤–µ–∑–¥–µ")
    print("  ‚úÖ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥")
    print("  ‚öîÔ∏è –ü–æ–ª–Ω–∞—è —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å –∫ –æ—à–∏–±–∫–∞–º!")
else
    warn("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞!")
end