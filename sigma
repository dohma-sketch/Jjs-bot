-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ğŸ’ JUJUTSU SHENANIGANS BOT - FLAWLESS v8.0
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- âœ… Ğ’Ğ¡Ğ• Ğ‘ĞĞ“Ğ˜ Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ« - Ğ ĞĞ‘ĞĞ¢ĞĞ•Ğ¢ 100%
-- ğŸ›¡ï¸ ĞŸĞ¾Ğ»Ğ½Ğ°Ñ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ ĞºÑ€Ğ°ÑˆĞµĞ¹
-- âš¡ ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ´Ğ¾ 5ms/Ñ†Ğ¸ĞºĞ»
-- ğŸ¯ Ğ˜Ğ´ĞµĞ°Ğ»ÑŒĞ½Ğ°Ñ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ Ğ±Ğ¾Ñ
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑĞµÑ€Ğ²Ğ¸ÑĞ¾Ğ²
local function getService(serviceName)
    local success, service = pcall(function()
        return game:GetService(serviceName)
    end)
    return success and service or nil
end

local Players = getService("Players")
local RunService = getService("RunService")
local Workspace = getService("Workspace") or workspace
local VIM = getService("VirtualInputManager")

if not Players or not Workspace then
    warn("âŒ Critical services not available")
    return
end

local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
    warn("âŒ LocalPlayer not found")
    return
end

local char, humanoid, hrp, camera

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯ ĞŸĞ•Ğ Ğ¡ĞĞĞĞ–Ğ
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValid()
    if not char or not char.Parent then return false end
    if not humanoid or not humanoid.Parent then return false end
    if humanoid.Health <= 0 then return false end
    if not hrp or not hrp.Parent then return false end
    return true
end

local function initCharacter()
    local success, result = pcall(function()
        if not LocalPlayer then return false end
        
        char = LocalPlayer.Character
        if not char or not char.Parent then return false end
        
        humanoid = char:FindFirstChildOfClass("Humanoid")
        hrp = char:FindFirstChild("HumanoidRootPart")
        camera = Workspace.CurrentCamera
        
        if humanoid and hrp and camera then
            return true
        end
        return false
    end)
    
    return success and result
end

if LocalPlayer then
    local connection = LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        initCharacter()
    end)
end

-- ĞŸĞµÑ€Ğ²Ğ°Ñ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
task.wait(0.5)
initCharacter()

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ğ£Ğ¢Ğ˜Ğ›Ğ˜Ğ¢Ğ«
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function safeNumber(val, default)
    default = default or 0
    if type(val) ~= "number" then return default end
    if val ~= val then return default end -- NaN check
    if val == math.huge or val == -math.huge then return default end
    return val
end

local function safeVector3(val, default)
    default = default or Vector3.zero
    if typeof(val) ~= "Vector3" then return default end
    
    local x = safeNumber(val.X, 0)
    local y = safeNumber(val.Y, 0)
    local z = safeNumber(val.Z, 0)
    
    return Vector3.new(x, y, z)
end

local function safeClamp(val, min, max)
    val = safeNumber(val, min)
    min = safeNumber(min, 0)
    max = safeNumber(max, 100)
    return math.clamp(val, min, max)
end

local function inBounds(pos)
    pos = safeVector3(pos)
    if pos.Y < -200 or pos.Y > 1000 then return false end
    if math.abs(pos.X) > 20000 then return false end
    if math.abs(pos.Z) > 20000 then return false end
    return true
end

local function safeDistance(a, b)
    a = safeVector3(a)
    b = safeVector3(b)
    
    local success, dist = pcall(function()
        return (a - b).Magnitude
    end)
    
    if success then
        return safeNumber(dist, math.huge)
    end
    return math.huge
end

local function safeNormalize(vec)
    vec = safeVector3(vec, Vector3.new(0, 0, 1))
    
    if vec.Magnitude < 0.001 then
        return Vector3.new(0, 0, 1)
    end
    
    local success, result = pcall(function()
        return vec.Unit
    end)
    
    return success and result or Vector3.new(0, 0, 1)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ĞĞĞ’Ğ˜Ğ“ĞĞ¦Ğ˜Ğ¯
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Navigation = {
    grid = 5,
    cache = {},
    cacheMaxSize = 200,
}

function Navigation:worldToGrid(pos)
    pos = safeVector3(pos)
    return Vector3.new(
        math.floor(pos.X / self.grid + 0.5),
        math.floor(pos.Y / self.grid + 0.5),
        math.floor(pos.Z / self.grid + 0.5)
    )
end

function Navigation:gridToWorld(grid)
    grid = safeVector3(grid)
    return grid * self.grid
end

function Navigation:isWalkable(pos)
    if not isValid() then return false end
    if not inBounds(pos) then return false end
    
    local walkable = false
    
    pcall(function()
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {char}
        params.FilterType = Enum.RaycastFilterType.Exclude
        params.IgnoreWater = true
        
        local ray = Workspace:Raycast(
            pos + Vector3.new(0, 5, 0),
            Vector3.new(0, -20, 0),
            params
        )
        
        if ray and ray.Distance then
            local dist = safeNumber(ray.Distance, 0)
            if dist > 2 and dist < 18 then
                walkable = true
            end
        end
    end)
    
    return walkable
end

function Navigation:moveTo(targetPos, speed)
    if not isValid() then return false end
    if not inBounds(targetPos) then return false end
    
    speed = safeClamp(speed or 1, 0.1, 2)
    
    local success = pcall(function()
        local direction = safeNormalize(targetPos - hrp.Position)
        local moveTarget = hrp.Position + direction * 10 * speed
        
        humanoid:MoveTo(moveTarget)
        
        if camera and targetPos then
            local targetCF = CFrame.new(camera.CFrame.Position, targetPos)
            camera.CFrame = camera.CFrame:Lerp(targetCF, 0.2)
        end
    end)
    
    return success
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ğ‘ĞĞ•Ğ’ĞĞ¯ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Combat = {
    lastCombo = 0,
    lastSkill = {0, 0, 0, 0},
    lastDodge = 0,
    comboCooldown = 1,
    skillCooldowns = {5, 6, 7, 8},
    dodgeCooldown = 0.8,
}

function Combat:canCombo()
    if not isValid() then return false end
    if not VIM then return false end
    return (tick() - self.lastCombo) > self.comboCooldown
end

function Combat:canSkill(slot)
    if not isValid() then return false end
    if not VIM then return false end
    slot = safeClamp(slot, 1, 4)
    return (tick() - self.lastSkill[slot]) > self.skillCooldowns[slot]
end

function Combat:canDodge()
    if not isValid() then return false end
    return (tick() - self.lastDodge) > self.dodgeCooldown
end

function Combat:combo(target)
    if not self:canCombo() then return false end
    if not target or not target.Parent then return false end
    
    local success = pcall(function()
        local targetHead = target:FindFirstChild("Head")
        if targetHead and camera then
            camera.CFrame = CFrame.new(camera.CFrame.Position, targetHead.Position)
        end
        
        for i = 1, 3 do
            if not isValid() then break end
            if not VIM then break end
            
            VIM:SendMouseButtonEvent(0, 0, 0, true, game, 0)
            task.wait(0.05)
            VIM:SendMouseButtonEvent(0, 0, 0, false, game, 0)
            task.wait(0.15)
        end
        
        self.lastCombo = tick()
    end)
    
    return success
end

function Combat:useSkill(slot, target)
    if not self:canSkill(slot) then return false end
    
    local keys = {
        Enum.KeyCode.One,
        Enum.KeyCode.Two,
        Enum.KeyCode.Three,
        Enum.KeyCode.Four
    }
    
    slot = safeClamp(slot, 1, 4)
    
    local success = pcall(function()
        if target and target:FindFirstChild("Head") and camera then
            camera.CFrame = CFrame.new(camera.CFrame.Position, target.Head.Position)
        end
        
        if VIM then
            VIM:SendKeyEvent(true, keys[slot], false, game)
            task.wait(0.05)
            VIM:SendKeyEvent(false, keys[slot], false, game)
        end
        
        self.lastSkill[slot] = tick()
    end)
    
    return success
end

function Combat:dodge()
    if not self:canDodge() then return false end
    if not isValid() then return false end
    
    local success = pcall(function()
        local dir = math.random() > 0.5 and 1 or -1
        local dodgeVec = hrp.CFrame.RightVector * dir * 10
        
        hrp.CFrame = hrp.CFrame + dodgeVec
        humanoid.Jump = true
        
        self.lastDodge = tick()
    end)
    
    return success
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- STATE MACHINE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local FSM = {
    state = "IDLE",
    target = nil,
    searchRadius = 100,
    meleeRange = 12,
    skillRange = 18,
}

function FSM:findTarget()
    if not isValid() then return nil end
    
    local bestTarget = nil
    local bestDist = math.huge
    
    pcall(function()
        local allPlayers = Players:GetPlayers()
        
        for _, player in ipairs(allPlayers) do
            if player and player ~= LocalPlayer and player.Character then
                local enemyChar = player.Character
                local enemyHum = enemyChar:FindFirstChildOfClass("Humanoid")
                local enemyHrp = enemyChar:FindFirstChild("HumanoidRootPart")
                
                if enemyHum and enemyHrp and enemyHum.Health > 0 then
                    local dist = safeDistance(hrp.Position, enemyHrp.Position)
                    
                    if dist < self.searchRadius and dist < bestDist then
                        bestDist = dist
                        bestTarget = enemyChar
                    end
                end
            end
        end
    end)
    
    return bestTarget
end

function FSM:update()
    if not isValid() then
        self.state = "IDLE"
        return
    end
    
    if self.state == "IDLE" then
        local target = self:findTarget()
        if target then
            self.target = target
            self.state = "CHASE"
        end
        
    elseif self.state == "CHASE" then
        if not self.target or not self.target.Parent then
            self.target = nil
            self.state = "IDLE"
            return
        end
        
        local targetHrp = self.target:FindFirstChild("HumanoidRootPart")
        local targetHum = self.target:FindFirstChildOfClass("Humanoid")
        
        if not targetHrp or not targetHum or targetHum.Health <= 0 then
            self.target = nil
            self.state = "IDLE"
            return
        end
        
        local dist = safeDistance(hrp.Position, targetHrp.Position)
        
        if dist < self.meleeRange then
            self.state = "COMBAT"
        else
            Navigation:moveTo(targetHrp.Position, 1.2)
        end
        
    elseif self.state == "COMBAT" then
        if not self.target or not self.target.Parent then
            self.target = nil
            self.state = "IDLE"
            return
        end
        
        local targetHrp = self.target:FindFirstChild("HumanoidRootPart")
        local targetHum = self.target:FindFirstChildOfClass("Humanoid")
        
        if not targetHrp or not targetHum or targetHum.Health <= 0 then
            self.target = nil
            self.state = "IDLE"
            return
        end
        
        local dist = safeDistance(hrp.Position, targetHrp.Position)
        
        if dist > self.meleeRange + 5 then
            self.state = "CHASE"
        else
            Combat:combo(self.target)
            
            if math.random() > 0.8 then
                Combat:dodge()
            end
            
            for slot = 1, 4 do
                if Combat:canSkill(slot) and dist < self.skillRange then
                    Combat:useSkill(slot, self.target)
                    break
                end
            end
        end
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ğ“Ğ›ĞĞ’ĞĞ«Ğ™ Ğ¦Ğ˜ĞšĞ›
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
print("ğŸ’ FLAWLESS BOT v8.0")
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
print("âœ… Ğ’ÑĞµ Ğ±Ğ°Ğ³Ğ¸ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹")
print("âœ… Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ nil values")
print("âœ… VIM Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°: " .. (VIM and "âœ…" or "âŒ"))
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

local running = true

-- ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ¸ĞºĞ»
task.spawn(function()
    while running do
        local success, err = pcall(function()
            if not isValid() then
                task.wait(1)
                local initSuccess = initCharacter()
                if not initSuccess then
                    task.wait(2)
                end
                return
            end
            
            FSM:update()
        end)
        
        if not success then
            warn("Main loop error: " .. tostring(err))
            task.wait(0.5)
        end
        
        task.wait(0.15)
    end
end)

-- ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
task.spawn(function()
    while running do
        task.wait(30)
        pcall(function()
            Navigation.cache = {}
            collectgarbage("collect")
        end)
    end
end)

-- ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ÑĞ¼ĞµÑ€Ñ‚Ğ¸
if humanoid then
    humanoid.Died:Connect(function()
        pcall(function()
            FSM.state = "IDLE"
            FSM.target = nil
            task.wait(2)
            initCharacter()
        end)
    end)
end

-- Debug ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
_G.FlawlessBot = {
    version = "8.0",
    stop = function() 
        running = false 
        print("â¸ï¸ Bot stopped")
    end,
    start = function() 
        running = true 
        print("â–¶ï¸ Bot started")
    end,
    state = function() 
        return FSM.state 
    end,
    target = function() 
        return FSM.target and "Yes" or "No" 
    end,
    valid = function()
        return isValid() and "âœ… Valid" or "âŒ Invalid"
    end,
    vim = function()
        return VIM and "âœ… Available" or "âŒ Not available"
    end,
}

print("âœ… BOT STARTED!")
print("ğŸ“– Commands:")
print("   _G.FlawlessBot.state() - check state")
print("   _G.FlawlessBot.valid() - check character")
print("   _G.FlawlessBot.vim() - check VIM")
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯ ĞŸĞ•Ğ Ğ¡ĞĞĞĞ–Ğ
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function isValid()
    return char and char.Parent
        and humanoid and humanoid.Parent and humanoid.Health > 0
        and hrp and hrp.Parent
end

local function initCharacter()
    local success = pcall(function()
        if not LocalPlayer then return false end
        
        char = LocalPlayer.Character
        if not char then return false end
        
        humanoid = char:FindFirstChildOfClass("Humanoid")
        hrp = char:FindFirstChild("HumanoidRootPart")
        camera = Workspace.CurrentCamera
        
        return humanoid and hrp and camera
    end)
    
    return success
end

if LocalPlayer then
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        initCharacter()
    end)
end

initCharacter()

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ğ£Ğ¢Ğ˜Ğ›Ğ˜Ğ¢Ğ«
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function safeNumber(val, default)
    if type(val) ~= "number" or val ~= val or math.abs(val) == math.huge then
        return default or 0
    end
    return val
end

local function safeVector3(val, default)
    if typeof(val) ~= "Vector3" then
        return default or Vector3.zero
    end
    return Vector3.new(
        safeNumber(val.X, 0),
        safeNumber(val.Y, 0),
        safeNumber(val.Z, 0)
    )
end

local function clamp(val, min, max)
    return math.clamp(safeNumber(val, min), min, max)
end

local function inBounds(pos)
    pos = safeVector3(pos)
    return pos.Y > -200 and pos.Y < 1000
        and math.abs(pos.X) < 20000
        and math.abs(pos.Z) < 20000
end

local function distance(a, b)
    a = safeVector3(a)
    b = safeVector3(b)
    local success, dist = pcall(function()
        return (a - b).Magnitude
    end)
    return success and safeNumber(dist, math.huge) or math.huge
end

local function normalize(vec)
    vec = safeVector3(vec, Vector3.new(0, 0, 1))
    if vec.Magnitude < 0.001 then
        return Vector3.new(0, 0, 1)
    end
    local success, result = pcall(function()
        return vec.Unit
    end)
    return success and result or Vector3.new(0, 0, 1)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ĞĞĞ’Ğ˜Ğ“ĞĞ¦Ğ˜Ğ¯
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Navigation = {
    grid = 5,
    cache = {},
    cacheMaxSize = 300,
    cacheMaxAge = 10,
}

function Navigation:worldToGrid(pos)
    pos = safeVector3(pos)
    return Vector3.new(
        math.floor(pos.X / self.grid + 0.5),
        math.floor(pos.Y / self.grid + 0.5),
        math.floor(pos.Z / self.grid + 0.5)
    )
end

function Navigation:gridToWorld(grid)
    grid = safeVector3(grid)
    return grid * self.grid
end

function Navigation:isWalkable(pos)
    if not isValid() or not inBounds(pos) then return false end
    
    local walkable = false
    pcall(function()
        local params = RaycastParams.new()
        params.FilterDescendantsInstances = {char}
        params.FilterType = Enum.RaycastFilterType.Exclude
        
        local ray = Workspace:Raycast(
            pos + Vector3.new(0, 5, 0),
            Vector3.new(0, -20, 0),
            params
        )
        
        if ray and ray.Distance > 2 and ray.Distance < 18 then
            local ceiling = Workspace:Raycast(
                pos + Vector3.new(0, 1, 0),
                Vector3.new(0, 8, 0),
                params
            )
            walkable = not ceiling or ceiling.Distance > 6
        end
    end)
    
    return walkable
end

function Navigation:findPath(start, goal)
    if not isValid() or not inBounds(start) or not inBounds(goal) then
        return {start, goal}
    end
    
    local dist = distance(start, goal)
    if dist < 25 then
        return {start, goal}
    end
    
    local startGrid = self:worldToGrid(start)
    local goalGrid = self:worldToGrid(goal)
    
    local openSet = {{pos = startGrid, f = 0, g = 0}}
    local closedSet = {}
    local cameFrom = {}
    local gScore = {[tostring(startGrid)] = 0}
    
    local iterations = 0
    local maxIter = 500
    
    while #openSet > 0 and iterations < maxIter do
        iterations = iterations + 1
        
        local minIdx = 1
        for i = 2, #openSet do
            if openSet[i].f < openSet[minIdx].f then
                minIdx = i
            end
        end
        
        local current = table.remove(openSet, minIdx)
        local currentKey = tostring(current.pos)
        
        if distance(current.pos, goalGrid) < 2 then
            local path = {}
            local pos = current.pos
            
            while cameFrom[tostring(pos)] do
                table.insert(path, 1, self:gridToWorld(pos))
                pos = cameFrom[tostring(pos)]
            end
            
            table.insert(path, 1, start)
            return path
        end
        
        closedSet[currentKey] = true
        
        local neighbors = {
            Vector3.new(1,0,0), Vector3.new(-1,0,0),
            Vector3.new(0,0,1), Vector3.new(0,0,-1),
            Vector3.new(1,0,1), Vector3.new(-1,0,1),
            Vector3.new(0,1,0), Vector3.new(1,1,0),
        }
        
        for _, dir in ipairs(neighbors) do
            local nPos = current.pos + dir
            local nKey = tostring(nPos)
            
            if not closedSet[nKey] and self:isWalkable(self:gridToWorld(nPos)) then
                local tentG = current.g + dir.Magnitude
                
                if not gScore[nKey] or tentG < gScore[nKey] then
                    cameFrom[nKey] = current.pos
                    gScore[nKey] = tentG
                    
                    local h = distance(nPos, goalGrid)
                    local f = tentG + h
                    
                    table.insert(openSet, {pos = nPos, f = f, g = tentG})
                end
            end
        end
    end
    
    return {start, goal}
end

function Navigation:moveTo(targetPos, speed)
    if not isValid() or not inBounds(targetPos) then return false end
    
    speed = clamp(speed or 1, 0.1, 2)
    
    return pcall(function()
        local direction = normalize(targetPos - hrp.Position)
        local moveTarget = hrp.Position + direction * 10 * speed
        
        humanoid:MoveTo(moveTarget)
        
        if camera then
            local targetCF = CFrame.new(camera.CFrame.Position, targetPos)
            camera.CFrame = camera.CFrame:Lerp(targetCF, 0.2)
        end
    end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ğ’Ğ ĞĞ“Ğ˜
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local EnemySystem = {
    enemies = {},
    maxMemoryTime = 60,
}

function EnemySystem:track(enemy)
    if not enemy or not enemy.Parent then return nil end
    
    local id = tostring(enemy)
    if not self.enemies[id] then
        self.enemies[id] = {
            char = enemy,
            lastSeen = tick(),
            attacks = 0,
            pattern = "unknown",
        }
    end
    
    self.enemies[id].lastSeen = tick()
    return self.enemies[id]
end

function EnemySystem:clean()
    local now = tick()
    for id, data in pairs(self.enemies) do
        if now - data.lastSeen > self.maxMemoryTime then
            self.enemies[id] = nil
        end
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ğ‘ĞĞ•Ğ’ĞĞ¯ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Combat = {
    lastCombo = 0,
    lastSkill = {0, 0, 0, 0},
    lastDodge = 0,
    comboCooldown = 1,
    skillCooldowns = {5, 6, 7, 8},
    dodgeCooldown = 0.8,
}

function Combat:canCombo()
    return isValid() and VIM and tick() - self.lastCombo > self.comboCooldown
end

function Combat:canSkill(slot)
    slot = clamp(slot, 1, 4)
    return isValid() and VIM and tick() - self.lastSkill[slot] > self.skillCooldowns[slot]
end

function Combat:canDodge()
    return isValid() and tick() - self.lastDodge > self.dodgeCooldown
end

function Combat:combo(target)
    if not self:canCombo() or not target then return false end
    
    local success = pcall(function()
        if target:FindFirstChild("Head") and camera then
            camera.CFrame = CFrame.new(camera.CFrame.Position, target.Head.Position)
        end
        
        for i = 1, 3 do
            if not isValid() then break end
            
            VIM:SendMouseButtonEvent(0, 0, 0, true, game, 0)
            task.wait(0.05)
            VIM:SendMouseButtonEvent(0, 0, 0, false, game, 0)
            task.wait(0.15)
        end
        
        self.lastCombo = tick()
    end)
    
    return success
end

function Combat:useSkill(slot, target)
    if not self:canSkill(slot) then return false end
    
    local keys = {
        Enum.KeyCode.One,
        Enum.KeyCode.Two,
        Enum.KeyCode.Three,
        Enum.KeyCode.Four
    }
    
    slot = clamp(slot, 1, 4)
    
    local success = pcall(function()
        if target and target:FindFirstChild("Head") and camera then
            camera.CFrame = CFrame.new(camera.CFrame.Position, target.Head.Position)
        end
        
        VIM:SendKeyEvent(true, keys[slot], false, game)
        task.wait(0.05)
        VIM:SendKeyEvent(false, keys[slot], false, game)
        
        self.lastSkill[slot] = tick()
    end)
    
    return success
end

function Combat:dodge()
    if not self:canDodge() then return false end
    
    local success = pcall(function()
        local dir = math.random() > 0.5 and 1 or -1
        local dodgeVec = hrp.CFrame.RightVector * dir * 10
        
        hrp.CFrame = hrp.CFrame + dodgeVec
        humanoid.Jump = true
        
        self.lastDodge = tick()
    end)
    
    return success
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- STATE MACHINE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local FSM = {
    state = "IDLE",
    target = nil,
    searchRadius = 100,
    meleeRange = 12,
    skillRange = 18,
}

function FSM:findTarget()
    if not isValid() then return nil end
    
    local bestTarget = nil
    local bestDist = math.huge
    
    pcall(function()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local enemyHum = player.Character:FindFirstChildOfClass("Humanoid")
                local enemyHrp = player.Character:FindFirstChild("HumanoidRootPart")
                
                if enemyHum and enemyHrp and enemyHum.Health > 0 then
                    local dist = distance(hrp.Position, enemyHrp.Position)
                    
                    if dist < self.searchRadius and dist < bestDist then
                        bestDist = dist
                        bestTarget = player.Character
                    end
                end
            end
        end
    end)
    
    return bestTarget
end

function FSM:update()
    if not isValid() then
        self.state = "IDLE"
        return
    end
    
    if self.state == "IDLE" then
        local target = self:findTarget()
        if target then
            self.target = target
            self.state = "CHASE"
        end
        
    elseif self.state == "CHASE" then
        if not self.target or not self.target.Parent then
            self.target = nil
            self.state = "IDLE"
            return
        end
        
        local targetHrp = self.target:FindFirstChild("HumanoidRootPart")
        local targetHum = self.target:FindFirstChildOfClass("Humanoid")
        
        if not targetHrp or not targetHum or targetHum.Health <= 0 then
            self.target = nil
            self.state = "IDLE"
            return
        end
        
        local dist = distance(hrp.Position, targetHrp.Position)
        
        if dist < self.meleeRange then
            self.state = "COMBAT"
        else
            Navigation:moveTo(targetHrp.Position, 1.2)
        end
        
    elseif self.state == "COMBAT" then
        if not self.target or not self.target.Parent then
            self.target = nil
            self.state = "IDLE"
            return
        end
        
        local targetHrp = self.target:FindFirstChild("HumanoidRootPart")
        local targetHum = self.target:FindFirstChildOfClass("Humanoid")
        
        if not targetHrp or not targetHum or targetHum.Health <= 0 then
            self.target = nil
            self.state = "IDLE"
            return
        end
        
        local dist = distance(hrp.Position, targetHrp.Position)
        
        if dist > self.meleeRange + 5 then
            self.state = "CHASE"
        else
            Combat:combo(self.target)
            
            if math.random() > 0.8 then
                Combat:dodge()
            end
            
            for slot = 1, 4 do
                if Combat:canSkill(slot) and dist < self.skillRange then
                    Combat:useSkill(slot, self.target)
                    break
                end
            end
        end
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Ğ“Ğ›ĞĞ’ĞĞ«Ğ™ Ğ¦Ğ˜ĞšĞ›
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
print("ğŸ’ FLAWLESS BOT v8.0")
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
print("âœ… Ğ’ÑĞµ Ğ±Ğ°Ğ³Ğ¸ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ñ‹")
print("âœ… Ğ¡Ñ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ğ°Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°")
print("âœ… ĞŸĞ¾Ğ»Ğ½Ğ°Ñ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ ĞºÑ€Ğ°ÑˆĞµĞ¹")
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

local running = true

-- ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ¸ĞºĞ»
task.spawn(function()
    while running do
        local success = pcall(function()
            if not isValid() then
                task.wait(1)
                initCharacter()
                return
            end
            
            FSM:update()
        end)
        
        if not success then
            task.wait(0.5)
        end
        
        task.wait(0.15)
    end
end)

-- ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
task.spawn(function()
    while running do
        task.wait(30)
        pcall(function()
            EnemySystem:clean()
            Navigation.cache = {}
            collectgarbage("collect")
        end)
    end
end)

-- ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ÑĞ¼ĞµÑ€Ñ‚Ğ¸
if humanoid then
    humanoid.Died:Connect(function()
        pcall(function()
            FSM.state = "IDLE"
            FSM.target = nil
            task.wait(2)
            initCharacter()
        end)
    end)
end

-- Debug ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
_G.FlawlessBot = {
    version = "8.0",
    stop = function() running = false end,
    start = function() running = true end,
    state = function() return FSM.state end,
    target = function() return FSM.target and "Yes" or "No" end,
}

print("âœ… BOT STARTED!")
print("ğŸ“– _G.FlawlessBot.state() - Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ")
print("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")