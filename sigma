-- jjs_agent_v4_final.lua
-- Финальная версия: nil-safe, защищённый главный цикл, улучшенный обход (steer + local BFS),
-- BodyVelocity fallback, safe IO, мониторинг урона, replay, bandit, Q/SARSA.
-- Убраны места, где могло быть "attempt to call a nil value". collectgarbage вызывается в pcall.

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local Workspace = workspace

-- Safe helpers
local function isFunction(f) return type(f) == "function" end
local function safePcallFunc(f, ...) if not isFunction(f) then return false end; local ok, res = pcall(f, ...); return ok, res end

-- VIM safe
local okVIM, VIM = pcall(function() return game:GetService("VirtualInputManager") end)
if not okVIM then VIM = nil end

-- Player / character
local LocalPlayer = Players.LocalPlayer
local function getCharacter()
    if not LocalPlayer then return nil end
    if LocalPlayer.Character then return LocalPlayer.Character end
    if LocalPlayer.CharacterAdded then
        local ok, ch = pcall(function() return LocalPlayer.CharacterAdded:Wait() end)
        return ok and ch or nil
    end
    return nil
end

local char = getCharacter()
local humanoid, hrp = nil, nil
local camera = Workspace.CurrentCamera

local function bindCharacterParts(waitFor)
    char = getCharacter()
    if not char then return false end
    if waitFor then
        humanoid = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
        hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")
    else
        humanoid = char:FindFirstChildOfClass("Humanoid") or char:FindFirstChild("Humanoid")
        hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or hrp
    end
    camera = Workspace.CurrentCamera or camera
    return humanoid ~= nil and hrp ~= nil
end
pcall(function() bindCharacterParts(false) end)
if LocalPlayer and LocalPlayer.CharacterAdded then
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(0.08)
        pcall(function() bindCharacterParts(true) end)
    end)
end

-- Config
local CFG = {
    alpha = 0.55, gamma = 0.9,
    epsilon = 0.95, epsilonMin = 0.02, epsilonDecay = 0.994,
    moveStep = 16,
    attackRange = 12,
    damageWindow = 0.9,
    collisionRayDist = 3,
    replayCapacity = 3000,
    replayBatch = 16,
    saveInterval = 25,
    minMoveDelta = 0.5,
    antiStuckAttempts = 3,
    idlePenaltyThreshold = 6,
    prioritizedReplay = true,
    maxStates = 4000,
    maxBanditContexts = 1000,
    qFile = "jjs_qtable.json",
    banditFile = "jjs_bandit.json",
    metaFile = "jjs_meta.json",
    mapUpdateInterval = 0.5,
    sensorDist = 128,
    sensorRays = 20,
    BVName = "_JJS_BV",
    debug = false,
    gridStep = 4,
    gridRadius = 24,
}

-- Safe file IO wrappers
local function hasFileIO()
    return type(isfile) == "function" and type(readfile) == "function" and type(writefile) == "function"
end
local function safeJSONEncode(obj)
    local ok, res = pcall(HttpService.JSONEncode, HttpService, obj)
    return ok and res or nil
end
local function safeJSONDecode(s)
    local ok, res = pcall(HttpService.JSONDecode, HttpService, s)
    return ok and res or nil
end
local function safeLoadJSON(name)
    if not hasFileIO() then return nil end
    local ok, txt = pcall(readfile, name)
    if not ok or type(txt) ~= "string" or #txt == 0 then return nil end
    return safeJSONDecode(txt)
end
local function safeSaveJSON(name, obj)
    if not hasFileIO() then return false end
    local enc = safeJSONEncode(obj)
    if not enc then return false end
    local ok = pcall(writefile, name, enc)
    return ok
end

-- Persistence
local Q = safeLoadJSON(CFG.qFile) or {}
local bandit = safeLoadJSON(CFG.banditFile) or {}
local meta = safeLoadJSON(CFG.metaFile) or {version = 4, created = os.time(), lastSave = os.time()}

-- Replay memory
local Replay = {}
Replay.__index = Replay
function Replay.new(cap)
    return setmetatable({mem = {}, cap = cap or 1000, sz = 0, idx = 1}, Replay)
end
function Replay:add(s,a,r,ns,done)
    if not s or not a then return end
    local priority = math.min(100, math.abs((r or 0)) + 1e-4)
    self.mem[self.idx] = {s = s, a = a, r = (r or 0), ns = (ns or s), done = (done or false), p = priority}
    self.idx = (self.idx % self.cap) + 1
    if self.sz < self.cap then self.sz = self.sz + 1 end
end
function Replay:sample(n)
    if self.sz == 0 then return {} end
    n = math.min(n, self.sz)
    local out = {}
    if CFG.prioritizedReplay then
        local total = 0
        for i=1,self.sz do total = total + (self.mem[i].p or 0) end
        if total <= 0 then
            for i=1,n do out[#out+1] = self.mem[math.random(1, self.sz)] end
            return out
        end
        for k=1,n do
            local pick = math.random() * total
            local acc = 0
            for i=1,self.sz do
                acc = acc + (self.mem[i].p or 0)
                if acc >= pick then out[#out+1] = self.mem[i]; break end
            end
        end
        return out
    else
        for i=1,n do out[#out+1] = self.mem[math.random(1, self.sz)] end
        return out
    end
end
local replay = Replay.new(CFG.replayCapacity)

-- Utilities
local function now() return tick() end
local function clamp(v, lo, hi) if v < lo then return lo end if v > hi then return hi end return v end
local function safeMag(a,b) if not a or not b then return math.huge end local ok, v = pcall(function() return (a - b).Magnitude end) return ok and v or math.huge end

-- Raycast wrapper
local function safeRaycast(origin, direction, length, blacklist)
    if not origin or not direction then return nil end
    local rp = RaycastParams.new()
    rp.FilterDescendantsInstances = blacklist or (char and {char}) or {}
    rp.FilterType = Enum.RaycastFilterType.Blacklist
    rp.IgnoreWater = true
    local ok, res = pcall(function() return Workspace:Raycast(origin, direction.Unit * (length or CFG.sensorDist), rp) end)
    return ok and res or nil
end

-- Map memory
local mapMemory = {}
local function posKey(vec)
    if not vec then return "nil" end
    return tostring(math.floor(vec.X+0.5)).."|"..tostring(math.floor(vec.Y+0.5)).."|"..tostring(math.floor(vec.Z+0.5))
end

local function scanRing(origin, rays)
    rays = math.max(1, rays or CFG.sensorRays)
    origin = origin or (hrp and hrp.Position) or Vector3.new(0,0,0)
    local out = {}
    for i=0, rays-1 do
        local ang = (i / math.max(1, rays)) * math.pi * 2
        local dir = Vector3.new(math.cos(ang), 0, math.sin(ang))
        local res = safeRaycast(origin + Vector3.new(0,1.5,0), dir, CFG.sensorDist)
        out[#out+1] = {dir = dir, hit = (res ~= nil), pos = (res and res.Position) or nil, inst = (res and res.Instance) or nil}
    end
    return out
end

local function updateMapOnce()
    if not hrp then return end
    local origin = hrp.Position
    local scan = scanRing(origin, CFG.sensorRays)
    for i=1,#scan do
        local s = scan[i]
        local dist = CFG.sensorDist
        if s.pos then dist = (s.pos - origin).Magnitude end
        local samplePos = origin + s.dir * math.min(dist, CFG.sensorDist)
        local key = posKey(samplePos)
        if key ~= "nil" then
            local nowt = now()
            local prev = mapMemory[key]
            if s.hit then
                mapMemory[key] = {kind = "blocked", t = nowt, c = (prev and math.min(1, (prev.c or 0) + 0.4)) or 0.6}
            else
                mapMemory[key] = {kind = "free", t = nowt, c = (prev and math.min(1, (prev.c or 0) + 0.3)) or 0.5}
            end
        end
    end
end

task.spawn(function()
    while true do
        task.wait(CFG.mapUpdateInterval or 0.5)
        pcall(updateMapOnce)
    end
end)

-- Movement helpers (BodyVelocity fallback)
local function ensureBV()
    if not hrp then return nil end
    local existing = hrp:FindFirstChild(CFG.BVName)
    if existing and existing:IsA("BodyVelocity") then return existing end
    local ok, obj = pcall(function()
        local b = Instance.new("BodyVelocity")
        b.Name = CFG.BVName
        b.MaxForce = Vector3.new(1e5,0,1e5)
        b.P = 3000
        b.Velocity = Vector3.new(0,0,0)
        b.Parent = hrp
        return b
    end)
    return ok and obj or nil
end
local function clearBV()
    if not hrp then return end
    local b = hrp:FindFirstChild(CFG.BVName)
    if b and b.Parent then pcall(function() b:Destroy() end) end
end
local function setVelocity(vec)
    if not hrp then return end
    if type(vec) ~= "Vector3" then return end
    local bv = ensureBV()
    if not bv then
        if humanoid and isFunction(humanoid.MoveTo) then
            pcall(function() humanoid:MoveTo(hrp.Position + Vector3.new(vec.X,0,vec.Z)) end)
        end
        return
    end
    pcall(function()
        local cur = bv.Velocity or Vector3.new(0,0,0)
        local s = 0.7
        bv.Velocity = Vector3.new(cur.X*(1-s) + vec.X*s, 0, cur.Z*(1-s) + vec.Z*s)
    end)
end

-- Steering helpers
local function rotateYUnit(vec, deg)
    if not vec or (vec.Magnitude and vec.Magnitude < 1e-6) then return nil end
    local cf = CFrame.Angles(0, math.rad(deg), 0)
    local r = cf:VectorToWorldSpace(vec)
    if not r or (r.Magnitude and r.Magnitude < 1e-6) then return nil end
    return Vector3.new(r.X,0,r.Z).Unit
end

local function isPathClearSimple(fromPos, dirUnit, length)
    if not fromPos or not dirUnit or (dirUnit.Magnitude and dirUnit.Magnitude < 1e-6) then return false end
    length = length or math.min(CFG.sensorDist, 16)
    local res = safeRaycast(fromPos + Vector3.new(0,1.5,0), dirUnit, length, {char})
    return res == nil
end

local function steerTo(desiredUnit)
    if not hrp or not desiredUnit or (desiredUnit.Magnitude and desiredUnit.Magnitude < 1e-6) then return nil end
    if isPathClearSimple(hrp.Position, desiredUnit, math.min(16, CFG.sensorDist)) then return desiredUnit end
    local angles = {15, -15, 30, -30, 60, -60, 90, -90}
    for _,a in ipairs(angles) do
        local r = rotateYUnit(desiredUnit, a)
        if r and isPathClearSimple(hrp.Position, r, 14) then return r end
    end
    local s = scanRing(hrp.Position, math.min(18, CFG.sensorRays))
    for i=1,#s do if not s[i].hit then return s[i].dir end end
    return nil
end

-- Input helpers safe
local function safeSendMouse(x,y,down)
    if not VIM or not isFunction(VIM.SendMouseButtonEvent) then return false end
    pcall(function() VIM:SendMouseButtonEvent(x,y,0,down,game,0) end)
    return true
end
local function safeSendKey(key, down)
    if not VIM or not isFunction(VIM.SendKeyEvent) then return false end
    pcall(function() VIM:SendKeyEvent(down, key, false, game) end)
    return true
end

local function doClick()
    if not camera then camera = Workspace.CurrentCamera end
    if not camera then return false end
    local ok, size = pcall(function() return camera.ViewportSize end)
    if not ok or not size then return false end
    local x,y = size.X/2, size.Y/2
    safeSendMouse(x,y,true); task.wait(0.04); safeSendMouse(x,y,false)
    return true
end
local function doHeavyClick()
    if not camera then camera = Workspace.CurrentCamera end
    if not camera then return false end
    local ok, size = pcall(function() return camera.ViewportSize end)
    if not ok or not size then return false end
    local x,y = size.X/2, size.Y/2
    safeSendMouse(x,y,true); task.wait(0.12); safeSendMouse(x,y,false)
    return true
end

local skillKeys = {Enum.KeyCode.One, Enum.KeyCode.Two, Enum.KeyCode.Three, Enum.KeyCode.Four}
local function pressSkill(idx)
    local key = skillKeys[idx]
    if not key then return false end
    safeSendKey(key, true); task.wait(0.06); safeSendKey(key, false)
    return true
end

-- Targeting & state
local function findNearestTarget()
    if not hrp then pcall(bindCharacterParts) end
    local nearest, nd = nil, math.huge
    for _,pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character.Parent then
            local ch = pl.Character
            local hrp2 = ch:FindFirstChild("HumanoidRootPart")
            local hum2 = ch:FindFirstChildOfClass("Humanoid")
            if hrp2 and hum2 and hum2.Health and hum2.Health > 0 then
                local ok, d = pcall(function() return (hrp.Position - hrp2.Position).Magnitude end)
                if ok and d and d < nd then nd, nearest = d, ch end
            end
        end
    end
    return nearest, nd
end

local function compressRecent(lastActions)
    if not lastActions or #lastActions == 0 then return "m_none" end
    local start = math.max(1, #lastActions - 2)
    local out = "m"
    for i = start, #lastActions do out = out .. "_" .. tostring(lastActions[i]) end
    return out
end

local function getState(target, lastActions)
    if not target or not target.Parent or not target:FindFirstChild("HumanoidRootPart") or not target:FindFirstChildOfClass("Humanoid") then
        return "no_target"
    end
    local ok, dist = pcall(function() return (hrp.Position - target.HumanoidRootPart.Position).Magnitude end)
    if not ok or not dist then dist = 9999 end
    local range = (dist < 6 and "close") or (dist < 15 and "mid") or "far"
    local rp = RaycastParams.new(); rp.FilterDescendantsInstances = {char}; rp.FilterType = Enum.RaycastFilterType.Blacklist; rp.IgnoreWater = true
    local vis = "novis"
    if target:FindFirstChild("Head") then
        local ok2, r = pcall(function() return Workspace:Raycast(hrp.Position, (target.Head.Position - hrp.Position), rp) end)
        if ok2 and (r == nil or (r.Instance and r.Instance:IsDescendantOf(target))) then vis = "vis" end
    end
    local okhp, th = pcall(function()
        local H = target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health or 0
        local M = math.max((target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").MaxHealth) or 1, 1)
        return (H and (H / M)) or 1
    end)
    if not okhp then th = 1 end
    local hpb = (th > 0.7 and "hp_high") or (th > 0.3 and "hp_med") or "hp_low"
    local mem = compressRecent(lastActions)
    local state = range .. "|" .. vis .. "|" .. hpb .. "|" .. mem
    if #state > 200 then state = state:sub(1,200) end
    return state
end

-- Q-table & actions
local actions = {"move_forward","move_backward","move_left","move_right","jump","idle","click_attack","skill_1","skill_2","skill_3","skill_4"}
local function initState(s)
    if not s then return end
    if not Q[s] then
        Q[s] = {}
        for i = 1, #actions do Q[s][i] = 0 end
    end
end
local function chooseAction(s)
    initState(s)
    if math.random() < (CFG.epsilon or 0.5) then
        return math.random(1,#actions)
    else
        local bestVal, bestIdx = -math.huge, 1
        for i,v in ipairs(Q[s] or {}) do if v and v > bestVal then bestVal, bestIdx = v, i end end
        return bestIdx
    end
end

-- Bandit (attacks)
local baseAttacks = {"click","heavy","skill1","skill2","skill3","skill4"}
local function ensureContext(ctx)
    if not ctx then return end
    if not bandit[ctx] then bandit[ctx] = {meta = {created = now(), last = now()}} end
    for _,nm in ipairs(baseAttacks) do
        if not bandit[ctx][nm] then bandit[ctx][nm] = {wins=0, plays=0} end
    end
    bandit[ctx].meta.last = now()
end
local function chooseAttackForContext(ctx)
    if not ctx then return "click" end
    ensureContext(ctx)
    local total = 0
    for _,v in pairs(bandit[ctx]) do if type(v)=="table" and v.plays then total = total + (v.plays) end end
    total = math.max(total,1)
    local best, bestVal = nil, -math.huge
    for name,st in pairs(bandit[ctx]) do
        if type(st)=="table" and st.plays ~= nil then
            local plays = st.plays or 0; local wins = st.wins or 0
            local avg = (plays>0) and (wins/plays) or 0.4
            local bonus = (plays>0) and math.sqrt(2*math.log(total)/math.max(1,plays)) or 1.0
            local val = avg + bonus
            if val > bestVal then bestVal, best = val, name end
        end
    end
    return best or "click"
end
local function registerAttack(ctx,name,success) if not ctx or not name then return end ensureContext(ctx) local s = bandit[ctx][name] s.plays = (s.plays or 0) + 1 if success then s.wins = (s.wins or 0) + 1 end end
local function pruneBandit()
    local keys = {}
    for k,v in pairs(bandit) do
        if type(v) == "table" and v.meta then
            local total = 0
            for an,av in pairs(v) do if type(av)=="table" and av.plays then total = total + (av.plays or 0) end end
            table.insert(keys, {k=k, score=total, last=v.meta.last})
        end
    end
    table.sort(keys, function(a,b) return a.score > b.score end)
    for i = CFG.maxBanditContexts+1, #keys do bandit[keys[i].k] = nil end
end

-- Damage monitoring
local lastMyHealth = (humanoid and humanoid.Health) or 100
local function monitorSelfDamage()
    if not humanoid then return false end
    local cur = humanoid.Health or lastMyHealth
    local changed = cur < lastMyHealth
    lastMyHealth = cur
    return changed
end

local activeMonitors = 0
local function monitorTargetDamage(target, startHP, window, callback)
    if not target or type(callback) ~= "function" then if callback then pcall(callback,false) end; return end
    if activeMonitors >= CFG.maxConcurrentMonitors then
        task.spawn(function()
            task.wait(math.min(0.18, window or 0.2))
            local ok, cur = pcall(function() return target and target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health end)
            pcall(callback, ok and cur and startHP and cur < startHP)
        end)
        return
    end
    activeMonitors = activeMonitors + 1
    task.spawn(function()
        local t0 = now(); local success = false
        while now() - t0 < (window or CFG.damageWindow) do
            if not target or not target.Parent or not target:FindFirstChildOfClass("Humanoid") then break end
            local ok, cur = pcall(function() return target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health end)
            if ok and cur and startHP and cur < startHP then success = true; break end
            task.wait(0.04)
        end
        pcall(callback, success)
        activeMonitors = math.max(0, activeMonitors - 1)
    end)
end

-- Reward
local lastActionIdx, lastSkillUsed, idleLoops = nil, nil, 0
local function computeReward(actionIdx, target, oldDist, collidedWithWall, gotDamage, didDamage, targetMovedAway)
    local actionName = actions[actionIdx] or "idle"
    local r = 0
    if target then
        local ok, newDist = pcall(function() return (hrp.Position - target.HumanoidRootPart.Position).Magnitude end)
        if ok and newDist then
            if newDist < (oldDist or math.huge) then r = r + 0.6 else r = r - 0.35 end
            if targetMovedAway then r = r - 0.9 end
        else r = r - 0.5 end
    else r = r - 0.6 end
    if collidedWithWall then r = r - 2.2 end
    if gotDamage then r = r - 2.5 end
    if didDamage then r = r + 3.2 end
    if actionName:match("skill") then
        if lastSkillUsed == actionName then r = r - 1.2 end
        lastSkillUsed = actionName
    else lastSkillUsed = nil end
    if lastActionIdx == actionIdx then r = r - 0.06 end
    lastActionIdx = actionIdx
    if actionName == "idle" then idleLoops = idleLoops + 1; if idleLoops > CFG.idlePenaltyThreshold then r = r - 0.2 end
    else idleLoops = 0 end
    return r
end

-- Q update & replay
local function safeMax(tbl)
    if not tbl or type(tbl) ~= "table" then return 0 end
    local m = -math.huge
    for i,v in ipairs(tbl) do if v and v > m then m = v end end
    if m == -math.huge then return 0 end
    return m
end
local function updateQ(state, aIdx, reward, nextState, nextAIdx, method)
    if not state or not aIdx then return end
    initState(state); initState(nextState)
    if method == "Q" then
        local maxNext = safeMax(Q[nextState])
        Q[state][aIdx] = (Q[state][aIdx] or 0) + CFG.alpha * (reward + CFG.gamma * maxNext - (Q[state][aIdx] or 0))
    else
        local nextVal = (Q[nextState] and Q[nextState][nextAIdx]) or 0
        Q[state][aIdx] = (Q[state][aIdx] or 0) + CFG.alpha * (reward + CFG.gamma * nextVal - (Q[state][aIdx] or 0))
    end
end

local function replayTrain()
    if replay.sz < 1 then return end
    local batch = replay:sample(CFG.replayBatch or 16)
    for _,t in ipairs(batch) do
        if t and t.s and t.a then
            local nextA = chooseAction(t.ns)
            updateQ(t.s, t.a, t.r, t.ns, nextA, "Q")
        end
    end
end

-- Prune & garbage
local function pruneQ()
    local count = 0 for _ in pairs(Q) do count = count + 1 end
    if count <= CFG.maxStates then return end
    local scores = {}
    for k,v in pairs(Q) do
        local s = 0
        for i=1,#v do s = s + math.abs(v[i] or 0) end
        table.insert(scores, {k=k, score=s})
    end
    table.sort(scores, function(a,b) return a.score < b.score end)
    for i=1, math.min(#scores, count - CFG.maxStates) do Q[scores[i].k] = nil end
    pcall(function() collectgarbage("collect") end)
end
local function pruneBanditAndGarbage()
    pcall(pruneBandit)
    local torem = {}
    for k,v in pairs(bandit) do
        if type(v)=="table" and v.meta and v.meta.last then
            local total = 0
            for an,av in pairs(v) do if type(av)=="table" and av.plays then total = total + (av.plays or 0) end end
            if total < 2 and (now() - v.meta.last) > 3600 then torem[#torem+1] = k end
        end
    end
    for _,k in ipairs(torem) do bandit[k] = nil end
    pcall(function() collectgarbage("collect") end)
end

-- Diagnostics
local metrics = {loops=0, collisions=0, hits=0, damageTaken=0, avgReward=0, samples=0}
_G.JJS_AGENT = _G.JJS_AGENT or {}
_G.JJS_AGENT.reset = function()
    Q = {}; bandit = {}; replay = Replay.new(CFG.replayCapacity)
    if hasFileIO() then safeSaveJSON(CFG.qFile, Q); safeSaveJSON(CFG.banditFile, bandit) end
    print("[JJS_AGENT] reset done")
end
_G.JJS_AGENT.dump = function() if hasFileIO() then safeSaveJSON("jjs_q_dump.json", Q); safeSaveJSON("jjs_bandit_dump.json", bandit) end; print("[JJS_AGENT] dump saved") end
_G.JJS_AGENT.prune = function() pruneQ(); pruneBanditAndGarbage(); print("[JJS_AGENT] prune done") end
_G.JJS_AGENT.status = function()
    local qcount = 0 for _ in pairs(Q) do qcount = qcount + 1 end
    local bcount = 0 for _ in pairs(bandit) do bcount = bcount + 1 end
    print(("status: qstates=%d bandit_ctx=%d replay=%d eps=%.4f"):format(qcount,bcount,replay.sz,CFG.epsilon))
end

local function logMetrics()
    local avg = metrics.samples > 0 and (metrics.avgReward / metrics.samples) or 0
    print(("[JJS AGENT] loops=%d collisions=%d hits=%d dmgTaken=%d avgR=%.3f eps=%.3f"):format(
        metrics.loops, metrics.collisions, metrics.hits, metrics.damageTaken, avg, CFG.epsilon))
end

-- Stuck detection
local lastPositions = {}
local function recordPosition()
    if not hrp then return end
    table.insert(lastPositions, 1, hrp.Position)
    if #lastPositions > 16 then table.remove(lastPositions) end
end
local function isStuck()
    if #lastPositions < 8 then return false end
    local sum = 0
    for i=1,6 do
        local a = lastPositions[i]; local b = lastPositions[i+1]
        if a and b then sum = sum + (a - b).Magnitude end
    end
    return sum < 0.6
end

-- Local grid planner BFS
local function toGrid(origin, step)
    local gx = math.floor(origin.X / step + 0.5)
    local gz = math.floor(origin.Z / step + 0.5)
    return gx, gz
end
local function fromGrid(gx, gz, y, step)
    return Vector3.new(gx * step, y or 0, gz * step)
end

local function planPathTo(targetPos)
    if not hrp or not targetPos then return nil end
    local step = CFG.gridStep
    local radius = CFG.gridRadius
    local origin = hrp.Position
    local gx0, gz0 = toGrid(origin, step)
    local gtx, gtz = toGrid(targetPos, step)
    local limit = math.floor(radius / step)
    local visited = {}
    local rootKey = tostring(gx0).."|"..tostring(gz0)
    visited[rootKey] = "__root"
    local q = {{gx = gx0, gz = gz0}}
    local dirs = {{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}}
    local foundKey = nil
    local iterations = 0
    local maxNodes = ((limit*2)+1)^2
    while #q > 0 and iterations < maxNodes do
        local node = table.remove(q,1); iterations = iterations + 1
        local key = tostring(node.gx).."|"..tostring(node.gz)
        if node.gx == gtx and node.gz == gtz then foundKey = key; break end
        for _,d in ipairs(dirs) do
            local ngx, ngz = node.gx + d[1], node.gz + d[2]
            if math.abs(ngx - gx0) <= limit and math.abs(ngz - gz0) <= limit then
                local k2 = tostring(ngx).."|"..tostring(ngz)
                if visited[k2] == nil then
                    local world = fromGrid(ngx, ngz, origin.Y, step)
                    -- check if cell is roughly free by raycasting down and small horizontal test
                    local floorHit = safeRaycast(world + Vector3.new(0,2,0), Vector3.new(0,-1,0), 4, {char})
                    local horiz = safeRaycast(world + Vector3.new(0,1.5,0), Vector3.new(1,0,0), step * 0.5, {char})
                    local blocked = horiz ~= nil and true or false
                    if not blocked and floorHit then
                        visited[k2] = key
                        q[#q+1] = {gx = ngx, gz = ngz}
                    else
                        visited[k2] = "__blocked"
                    end
                end
            end
        end
    end
    if not foundKey then
        local bestKey, bestD = nil, math.huge
        for k,v in pairs(visited) do
            if v ~= "__blocked" then
                local sx, sz = k:match("([^|]+)|([^|]+)")
                sx, sz = tonumber(sx), tonumber(sz)
                if sx and sz then
                    local world = fromGrid(sx, sz, origin.Y, step)
                    local d = (world - targetPos).Magnitude
                    if d < bestD then bestD, bestKey = d, k end
                end
            end
        end
        foundKey = bestKey
        if not foundKey then return nil end
    end
    local path = {}
    local cur = foundKey
    while cur and cur ~= "__root" do
        local sx, sz = cur:match("([^|]+)|([^|]+)")
        sx, sz = tonumber(sx), tonumber(sz)
        if not sx or not sz then break end
        local world = fromGrid(sx, sz, origin.Y, step)
        table.insert(path, 1, world)
        cur = visited[cur]
    end
    if #path > 0 and (path[1] - origin).Magnitude < step * 0.6 then table.remove(path,1) end
    return path
end

-- Camera rotate only
local function rotateCameraToTarget(target)
    if not camera or not target or not target:FindFirstChild("Head") then return end
    pcall(function()
        local camPos = camera.CFrame.Position
        local look = target.Head.Position
        camera.CFrame = CFrame.new(camPos, look)
    end)
end

-- Main loop
local lastSave = now()
local loopTick = 0
local recentActions = {}
local function pushRecent(a) recentActions[#recentActions+1] = a; if #recentActions > 6 then table.remove(recentActions,1) end end

local function mainLoop()
    while true do
        loopTick = loopTick + 1
        metrics.loops = metrics.loops + 1
        pcall(recordPosition)

        if not (char and char.Parent and humanoid and hrp) then
            pcall(bindCharacterParts)
            task.wait(0.12)
            goto CONT
        end

        local target, oldDist = findNearestTarget()
        oldDist = oldDist or math.huge

        if target then rotateCameraToTarget(target) end

        local state = getState(target, recentActions)
        initState(state)
        local actionIdx = chooseAction(state)
        local actionName = actions[actionIdx] or "idle"

        local visible = false
        if target and target:FindFirstChild("Head") and hrp then
            local ok, r = pcall(function()
                local rp = RaycastParams.new(); rp.FilterDescendantsInstances = {char}; rp.FilterType = Enum.RaycastFilterType.Blacklist; rp.IgnoreWater = true
                return Workspace:Raycast(hrp.Position, (target.Head.Position - hrp.Position), rp)
            end)
            if ok and (r == nil or (r.Instance and r.Instance:IsDescendantOf(target))) then visible = true end
        end

        local collided = false; local attackName = nil; local targetStartHP = nil
        if actionName == "move_forward" and target and target:FindFirstChild("HumanoidRootPart") then
            local dir = (target.HumanoidRootPart.Position - hrp.Position)
            if dir and dir.Magnitude > 0.2 then
                local desired = Vector3.new(dir.X,0,dir.Z).Unit
                local steer = steerTo(desired)
                if steer then
                    setVelocity(steer * CFG.moveStep)
                else
                    local path = planPathTo(target.HumanoidRootPart.Position)
                    if path and #path > 0 then
                        local nextPoint = path[1]
                        local toNext = Vector3.new(nextPoint.X - hrp.Position.X, 0, nextPoint.Z - hrp.Position.Z)
                        if toNext.Magnitude > 0.05 then
                            local steer2 = steerTo(toNext.Unit)
                            if steer2 then setVelocity(steer2 * CFG.moveStep) else collided=true; metrics.collisions = metrics.collisions + 1; clearBV() end
                        end
                    else
                        collided=true; metrics.collisions = metrics.collisions + 1; clearBV()
                    end
                end
            end
        elseif actionName == "move_backward" and target and target:FindFirstChild("HumanoidRootPart") then
            local dir = (hrp.Position - target.HumanoidRootPart.Position)
            if dir and dir.Magnitude > 0.2 then
                local steer = steerTo(Vector3.new(dir.X,0,dir.Z).Unit)
                if steer then setVelocity(steer * CFG.moveStep) else collided=true; metrics.collisions = metrics.collisions + 1; clearBV() end
            end
        elseif actionName == "move_left" and target and target:FindFirstChild("HumanoidRootPart") then
            local dir=(target.HumanoidRootPart.Position - hrp.Position); local left = Vector3.new(-dir.Z,0,dir.X)
            if left and left.Magnitude > 0 then local steer = steerTo(left.Unit); if steer then setVelocity(steer * CFG.moveStep) else collided=true; metrics.collisions = metrics.collisions + 1; clearBV() end end
        elseif actionName == "move_right" and target and target:FindFirstChild("HumanoidRootPart") then
            local dir=(target.HumanoidRootPart.Position - hrp.Position); local right = Vector3.new(dir.Z,0,-dir.X)
            if right and right.Magnitude > 0 then local steer = steerTo(right.Unit); if steer then setVelocity(steer * CFG.moveStep) else collided=true; metrics.collisions = metrics.collisions + 1; clearBV() end end
        elseif actionName == "jump" then pcall(function() if humanoid then humanoid.Jump = true end end); task.wait(0.12); pcall(function() if humanoid then humanoid.Jump = false end end)
        elseif actionName == "idle" then clearBV(); task.wait(0.06)
        elseif actionName == "click_attack" then
            if target and target:FindFirstChildOfClass("Humanoid") then
                attackName = "click"; targetStartHP = (target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health) or nil
                doClick()
                monitorTargetDamage(target, targetStartHP, CFG.damageWindow, function(success) if success then metrics.hits = metrics.hits + 1 end registerAttack(state, attackName, success) end)
            else task.wait(0.05) end
        elseif actionName:match("^skill_") then
            local idx = tonumber(actionName:match("skill_(%d)"))
            if idx and idx >= 1 and idx <= #skillKeys then
                attackName = "skill" .. tostring(idx)
                if target and target:FindFirstChildOfClass("Humanoid") then targetStartHP = (target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health) or nil end
                pressSkill(idx)
                monitorTargetDamage(target, targetStartHP, CFG.damageWindow, function(success) if success then metrics.hits = metrics.hits + 1 end registerAttack(state, attackName, success) end)
            end
        end

        task.wait(0.10)

        local gotDamage = monitorSelfDamage()
        if gotDamage then metrics.damageTaken = metrics.damageTaken + 1 end

        local targetMovedAway = false
        if target and target.Parent and target:FindFirstChild("HumanoidRootPart") and oldDist then
            local ok, newD = pcall(function() return (hrp.Position - target.HumanoidRootPart.Position).Magnitude end)
            if ok and newD and newD > oldDist + 0.4 then targetMovedAway = true end
        end

        local didDamageHeuristic = false
        if target and target:FindFirstChildOfClass("Humanoid") and targetStartHP then
            local ok, cur = pcall(function() return target:FindFirstChildOfClass("Humanoid") and target:FindFirstChildOfClass("Humanoid").Health end)
            if ok and cur and cur < targetStartHP then didDamageHeuristic = true end
        end

        local r = computeReward(actionIdx, target, oldDist, collided, gotDamage, didDamageHeuristic, targetMovedAway)
        metrics.avgReward = (metrics.avgReward or 0) + r; metrics.samples = (metrics.samples or 0) + 1

        pushRecent(actionIdx)
        local nextState = getState(target, recentActions)
        initState(nextState)
        local nextAction = chooseAction(nextState)

        local method = "SARSA"
        if actionName == "click_attack" or actionName:match("^skill_") then method = "Q" end

        replay:add(state, actionIdx, r, nextState, false)
        updateQ(state, actionIdx, r, nextState, nextAction, method)

        if loopTick % 6 == 0 then pcall(replayTrain) end
        if loopTick % 300 == 0 then pcall(pruneQ); pcall(pruneBanditAndGarbage) end

        if now() - lastSave > CFG.saveInterval then
            pcall(function()
                if hasFileIO() then safeSaveJSON(CFG.qFile, Q); safeSaveJSON(CFG.banditFile, bandit); meta.lastSave = os.time(); safeSaveJSON(CFG.metaFile, meta) end
            end)
            lastSave = now()
        end

        if CFG.epsilon and CFG.epsilon > CFG.epsilonMin then CFG.epsilon = clamp(CFG.epsilon * CFG.epsilonDecay, CFG.epsilonMin, 1) end

        if loopTick % 240 == 0 then logMetrics(); pcall(function() collectgarbage("collect") end) end

        if isStuck() then
            for i=1,CFG.antiStuckAttempts do
                local ang = math.random() * math.pi * 2
                local try = Vector3.new(math.cos(ang), 0, math.sin(ang))
                local steer = steerTo(try)
                if steer then setVelocity(steer * CFG.moveStep) end
                task.wait(0.08)
            end
        end

        task.wait(0.03)
        ::CONT::
    end
end

-- Run main loop protected
task.spawn(function()
    xpcall(mainLoop, function(err) print("[JJS_AGENT ERROR] "..tostring(err).."\n"..(debug and debug.traceback() or "")) end)
end)

print("[JJS_AGENT] v4 final loaded")